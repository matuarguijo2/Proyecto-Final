
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Donante
 * 
 */
export type Donante = $Result.DefaultSelection<Prisma.$DonantePayload>
/**
 * Model Campania
 * 
 */
export type Campania = $Result.DefaultSelection<Prisma.$CampaniaPayload>
/**
 * Model Hospital
 * 
 */
export type Hospital = $Result.DefaultSelection<Prisma.$HospitalPayload>
/**
 * Model Donacion
 * 
 */
export type Donacion = $Result.DefaultSelection<Prisma.$DonacionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GrupoSanguineo: {
  A: 'A',
  B: 'B',
  AB: 'AB',
  O: 'O'
};

export type GrupoSanguineo = (typeof GrupoSanguineo)[keyof typeof GrupoSanguineo]


export const FatorRH: {
  positivo: 'positivo',
  negativo: 'negativo'
};

export type FatorRH = (typeof FatorRH)[keyof typeof FatorRH]


export const TipoDonacion: {
  sangre_completa: 'sangre_completa',
  plasma: 'plasma',
  plaqueta: 'plaqueta'
};

export type TipoDonacion = (typeof TipoDonacion)[keyof typeof TipoDonacion]


export const EstadoDonacion: {
  exitosa: 'exitosa',
  rechazada: 'rechazada',
  pendiente: 'pendiente'
};

export type EstadoDonacion = (typeof EstadoDonacion)[keyof typeof EstadoDonacion]


export const EstadoDonante: {
  activo: 'activo',
  inactivo: 'inactivo',
  suspendido: 'suspendido'
};

export type EstadoDonante = (typeof EstadoDonante)[keyof typeof EstadoDonante]


export const Sexo: {
  Masculino: 'Masculino',
  Femenino: 'Femenino'
};

export type Sexo = (typeof Sexo)[keyof typeof Sexo]

}

export type GrupoSanguineo = $Enums.GrupoSanguineo

export const GrupoSanguineo: typeof $Enums.GrupoSanguineo

export type FatorRH = $Enums.FatorRH

export const FatorRH: typeof $Enums.FatorRH

export type TipoDonacion = $Enums.TipoDonacion

export const TipoDonacion: typeof $Enums.TipoDonacion

export type EstadoDonacion = $Enums.EstadoDonacion

export const EstadoDonacion: typeof $Enums.EstadoDonacion

export type EstadoDonante = $Enums.EstadoDonante

export const EstadoDonante: typeof $Enums.EstadoDonante

export type Sexo = $Enums.Sexo

export const Sexo: typeof $Enums.Sexo

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Donantes
 * const donantes = await prisma.donante.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Donantes
   * const donantes = await prisma.donante.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.donante`: Exposes CRUD operations for the **Donante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donantes
    * const donantes = await prisma.donante.findMany()
    * ```
    */
  get donante(): Prisma.DonanteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campania`: Exposes CRUD operations for the **Campania** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campanias
    * const campanias = await prisma.campania.findMany()
    * ```
    */
  get campania(): Prisma.CampaniaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hospital`: Exposes CRUD operations for the **Hospital** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospitals
    * const hospitals = await prisma.hospital.findMany()
    * ```
    */
  get hospital(): Prisma.HospitalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.donacion`: Exposes CRUD operations for the **Donacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donacions
    * const donacions = await prisma.donacion.findMany()
    * ```
    */
  get donacion(): Prisma.DonacionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Donante: 'Donante',
    Campania: 'Campania',
    Hospital: 'Hospital',
    Donacion: 'Donacion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "donante" | "campania" | "hospital" | "donacion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Donante: {
        payload: Prisma.$DonantePayload<ExtArgs>
        fields: Prisma.DonanteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonanteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonanteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>
          }
          findFirst: {
            args: Prisma.DonanteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonanteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>
          }
          findMany: {
            args: Prisma.DonanteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>[]
          }
          create: {
            args: Prisma.DonanteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>
          }
          createMany: {
            args: Prisma.DonanteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DonanteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>[]
          }
          delete: {
            args: Prisma.DonanteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>
          }
          update: {
            args: Prisma.DonanteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>
          }
          deleteMany: {
            args: Prisma.DonanteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DonanteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DonanteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>[]
          }
          upsert: {
            args: Prisma.DonanteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonantePayload>
          }
          aggregate: {
            args: Prisma.DonanteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonante>
          }
          groupBy: {
            args: Prisma.DonanteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonanteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DonanteCountArgs<ExtArgs>
            result: $Utils.Optional<DonanteCountAggregateOutputType> | number
          }
        }
      }
      Campania: {
        payload: Prisma.$CampaniaPayload<ExtArgs>
        fields: Prisma.CampaniaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaniaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaniaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>
          }
          findFirst: {
            args: Prisma.CampaniaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaniaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>
          }
          findMany: {
            args: Prisma.CampaniaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>[]
          }
          create: {
            args: Prisma.CampaniaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>
          }
          createMany: {
            args: Prisma.CampaniaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaniaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>[]
          }
          delete: {
            args: Prisma.CampaniaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>
          }
          update: {
            args: Prisma.CampaniaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>
          }
          deleteMany: {
            args: Prisma.CampaniaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaniaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaniaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>[]
          }
          upsert: {
            args: Prisma.CampaniaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaniaPayload>
          }
          aggregate: {
            args: Prisma.CampaniaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampania>
          }
          groupBy: {
            args: Prisma.CampaniaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaniaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaniaCountArgs<ExtArgs>
            result: $Utils.Optional<CampaniaCountAggregateOutputType> | number
          }
        }
      }
      Hospital: {
        payload: Prisma.$HospitalPayload<ExtArgs>
        fields: Prisma.HospitalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HospitalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HospitalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findFirst: {
            args: Prisma.HospitalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HospitalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          findMany: {
            args: Prisma.HospitalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          create: {
            args: Prisma.HospitalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          createMany: {
            args: Prisma.HospitalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HospitalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          delete: {
            args: Prisma.HospitalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          update: {
            args: Prisma.HospitalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          deleteMany: {
            args: Prisma.HospitalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HospitalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HospitalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>[]
          }
          upsert: {
            args: Prisma.HospitalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalPayload>
          }
          aggregate: {
            args: Prisma.HospitalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospital>
          }
          groupBy: {
            args: Prisma.HospitalGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospitalGroupByOutputType>[]
          }
          count: {
            args: Prisma.HospitalCountArgs<ExtArgs>
            result: $Utils.Optional<HospitalCountAggregateOutputType> | number
          }
        }
      }
      Donacion: {
        payload: Prisma.$DonacionPayload<ExtArgs>
        fields: Prisma.DonacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          findFirst: {
            args: Prisma.DonacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          findMany: {
            args: Prisma.DonacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>[]
          }
          create: {
            args: Prisma.DonacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          createMany: {
            args: Prisma.DonacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DonacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>[]
          }
          delete: {
            args: Prisma.DonacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          update: {
            args: Prisma.DonacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          deleteMany: {
            args: Prisma.DonacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DonacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DonacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>[]
          }
          upsert: {
            args: Prisma.DonacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          aggregate: {
            args: Prisma.DonacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonacion>
          }
          groupBy: {
            args: Prisma.DonacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DonacionCountArgs<ExtArgs>
            result: $Utils.Optional<DonacionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    donante?: DonanteOmit
    campania?: CampaniaOmit
    hospital?: HospitalOmit
    donacion?: DonacionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DonanteCountOutputType
   */

  export type DonanteCountOutputType = {
    donaciones: number
  }

  export type DonanteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donaciones?: boolean | DonanteCountOutputTypeCountDonacionesArgs
  }

  // Custom InputTypes
  /**
   * DonanteCountOutputType without action
   */
  export type DonanteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DonanteCountOutputType
     */
    select?: DonanteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DonanteCountOutputType without action
   */
  export type DonanteCountOutputTypeCountDonacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonacionWhereInput
  }


  /**
   * Count Type CampaniaCountOutputType
   */

  export type CampaniaCountOutputType = {
    donaciones: number
  }

  export type CampaniaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donaciones?: boolean | CampaniaCountOutputTypeCountDonacionesArgs
  }

  // Custom InputTypes
  /**
   * CampaniaCountOutputType without action
   */
  export type CampaniaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaniaCountOutputType
     */
    select?: CampaniaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaniaCountOutputType without action
   */
  export type CampaniaCountOutputTypeCountDonacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonacionWhereInput
  }


  /**
   * Count Type HospitalCountOutputType
   */

  export type HospitalCountOutputType = {
    campanias: number
    donaciones: number
  }

  export type HospitalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campanias?: boolean | HospitalCountOutputTypeCountCampaniasArgs
    donaciones?: boolean | HospitalCountOutputTypeCountDonacionesArgs
  }

  // Custom InputTypes
  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalCountOutputType
     */
    select?: HospitalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountCampaniasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaniaWhereInput
  }

  /**
   * HospitalCountOutputType without action
   */
  export type HospitalCountOutputTypeCountDonacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonacionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Donante
   */

  export type AggregateDonante = {
    _count: DonanteCountAggregateOutputType | null
    _avg: DonanteAvgAggregateOutputType | null
    _sum: DonanteSumAggregateOutputType | null
    _min: DonanteMinAggregateOutputType | null
    _max: DonanteMaxAggregateOutputType | null
  }

  export type DonanteAvgAggregateOutputType = {
    id: number | null
  }

  export type DonanteSumAggregateOutputType = {
    id: number | null
  }

  export type DonanteMinAggregateOutputType = {
    id: number | null
    dni: string | null
    nombre: string | null
    apellido: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    isActive: boolean | null
    grupo_sanguineo: $Enums.GrupoSanguineo | null
    factor_rh: $Enums.FatorRH | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sexo | null
    fecha_ultima_donacion: Date | null
    estado: $Enums.EstadoDonante | null
  }

  export type DonanteMaxAggregateOutputType = {
    id: number | null
    dni: string | null
    nombre: string | null
    apellido: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    isActive: boolean | null
    grupo_sanguineo: $Enums.GrupoSanguineo | null
    factor_rh: $Enums.FatorRH | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sexo | null
    fecha_ultima_donacion: Date | null
    estado: $Enums.EstadoDonante | null
  }

  export type DonanteCountAggregateOutputType = {
    id: number
    dni: number
    nombre: number
    apellido: number
    email: number
    password: number
    createdAt: number
    isActive: number
    grupo_sanguineo: number
    factor_rh: number
    fecha_nacimiento: number
    sexo: number
    fecha_ultima_donacion: number
    estado: number
    _all: number
  }


  export type DonanteAvgAggregateInputType = {
    id?: true
  }

  export type DonanteSumAggregateInputType = {
    id?: true
  }

  export type DonanteMinAggregateInputType = {
    id?: true
    dni?: true
    nombre?: true
    apellido?: true
    email?: true
    password?: true
    createdAt?: true
    isActive?: true
    grupo_sanguineo?: true
    factor_rh?: true
    fecha_nacimiento?: true
    sexo?: true
    fecha_ultima_donacion?: true
    estado?: true
  }

  export type DonanteMaxAggregateInputType = {
    id?: true
    dni?: true
    nombre?: true
    apellido?: true
    email?: true
    password?: true
    createdAt?: true
    isActive?: true
    grupo_sanguineo?: true
    factor_rh?: true
    fecha_nacimiento?: true
    sexo?: true
    fecha_ultima_donacion?: true
    estado?: true
  }

  export type DonanteCountAggregateInputType = {
    id?: true
    dni?: true
    nombre?: true
    apellido?: true
    email?: true
    password?: true
    createdAt?: true
    isActive?: true
    grupo_sanguineo?: true
    factor_rh?: true
    fecha_nacimiento?: true
    sexo?: true
    fecha_ultima_donacion?: true
    estado?: true
    _all?: true
  }

  export type DonanteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donante to aggregate.
     */
    where?: DonanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donantes to fetch.
     */
    orderBy?: DonanteOrderByWithRelationInput | DonanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donantes
    **/
    _count?: true | DonanteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonanteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonanteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonanteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonanteMaxAggregateInputType
  }

  export type GetDonanteAggregateType<T extends DonanteAggregateArgs> = {
        [P in keyof T & keyof AggregateDonante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonante[P]>
      : GetScalarType<T[P], AggregateDonante[P]>
  }




  export type DonanteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonanteWhereInput
    orderBy?: DonanteOrderByWithAggregationInput | DonanteOrderByWithAggregationInput[]
    by: DonanteScalarFieldEnum[] | DonanteScalarFieldEnum
    having?: DonanteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonanteCountAggregateInputType | true
    _avg?: DonanteAvgAggregateInputType
    _sum?: DonanteSumAggregateInputType
    _min?: DonanteMinAggregateInputType
    _max?: DonanteMaxAggregateInputType
  }

  export type DonanteGroupByOutputType = {
    id: number
    dni: string
    nombre: string
    apellido: string
    email: string
    password: string
    createdAt: Date
    isActive: boolean
    grupo_sanguineo: $Enums.GrupoSanguineo
    factor_rh: $Enums.FatorRH
    fecha_nacimiento: Date
    sexo: $Enums.Sexo
    fecha_ultima_donacion: Date | null
    estado: $Enums.EstadoDonante
    _count: DonanteCountAggregateOutputType | null
    _avg: DonanteAvgAggregateOutputType | null
    _sum: DonanteSumAggregateOutputType | null
    _min: DonanteMinAggregateOutputType | null
    _max: DonanteMaxAggregateOutputType | null
  }

  type GetDonanteGroupByPayload<T extends DonanteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonanteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonanteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonanteGroupByOutputType[P]>
            : GetScalarType<T[P], DonanteGroupByOutputType[P]>
        }
      >
    >


  export type DonanteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    isActive?: boolean
    grupo_sanguineo?: boolean
    factor_rh?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    fecha_ultima_donacion?: boolean
    estado?: boolean
    donaciones?: boolean | Donante$donacionesArgs<ExtArgs>
    _count?: boolean | DonanteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donante"]>

  export type DonanteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    isActive?: boolean
    grupo_sanguineo?: boolean
    factor_rh?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    fecha_ultima_donacion?: boolean
    estado?: boolean
  }, ExtArgs["result"]["donante"]>

  export type DonanteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dni?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    isActive?: boolean
    grupo_sanguineo?: boolean
    factor_rh?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    fecha_ultima_donacion?: boolean
    estado?: boolean
  }, ExtArgs["result"]["donante"]>

  export type DonanteSelectScalar = {
    id?: boolean
    dni?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    isActive?: boolean
    grupo_sanguineo?: boolean
    factor_rh?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    fecha_ultima_donacion?: boolean
    estado?: boolean
  }

  export type DonanteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dni" | "nombre" | "apellido" | "email" | "password" | "createdAt" | "isActive" | "grupo_sanguineo" | "factor_rh" | "fecha_nacimiento" | "sexo" | "fecha_ultima_donacion" | "estado", ExtArgs["result"]["donante"]>
  export type DonanteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donaciones?: boolean | Donante$donacionesArgs<ExtArgs>
    _count?: boolean | DonanteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DonanteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DonanteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DonantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Donante"
    objects: {
      donaciones: Prisma.$DonacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dni: string
      nombre: string
      apellido: string
      email: string
      password: string
      createdAt: Date
      isActive: boolean
      grupo_sanguineo: $Enums.GrupoSanguineo
      factor_rh: $Enums.FatorRH
      fecha_nacimiento: Date
      sexo: $Enums.Sexo
      fecha_ultima_donacion: Date | null
      estado: $Enums.EstadoDonante
    }, ExtArgs["result"]["donante"]>
    composites: {}
  }

  type DonanteGetPayload<S extends boolean | null | undefined | DonanteDefaultArgs> = $Result.GetResult<Prisma.$DonantePayload, S>

  type DonanteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DonanteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DonanteCountAggregateInputType | true
    }

  export interface DonanteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donante'], meta: { name: 'Donante' } }
    /**
     * Find zero or one Donante that matches the filter.
     * @param {DonanteFindUniqueArgs} args - Arguments to find a Donante
     * @example
     * // Get one Donante
     * const donante = await prisma.donante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DonanteFindUniqueArgs>(args: SelectSubset<T, DonanteFindUniqueArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Donante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DonanteFindUniqueOrThrowArgs} args - Arguments to find a Donante
     * @example
     * // Get one Donante
     * const donante = await prisma.donante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DonanteFindUniqueOrThrowArgs>(args: SelectSubset<T, DonanteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonanteFindFirstArgs} args - Arguments to find a Donante
     * @example
     * // Get one Donante
     * const donante = await prisma.donante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DonanteFindFirstArgs>(args?: SelectSubset<T, DonanteFindFirstArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonanteFindFirstOrThrowArgs} args - Arguments to find a Donante
     * @example
     * // Get one Donante
     * const donante = await prisma.donante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DonanteFindFirstOrThrowArgs>(args?: SelectSubset<T, DonanteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Donantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonanteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donantes
     * const donantes = await prisma.donante.findMany()
     * 
     * // Get first 10 Donantes
     * const donantes = await prisma.donante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donanteWithIdOnly = await prisma.donante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DonanteFindManyArgs>(args?: SelectSubset<T, DonanteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Donante.
     * @param {DonanteCreateArgs} args - Arguments to create a Donante.
     * @example
     * // Create one Donante
     * const Donante = await prisma.donante.create({
     *   data: {
     *     // ... data to create a Donante
     *   }
     * })
     * 
     */
    create<T extends DonanteCreateArgs>(args: SelectSubset<T, DonanteCreateArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Donantes.
     * @param {DonanteCreateManyArgs} args - Arguments to create many Donantes.
     * @example
     * // Create many Donantes
     * const donante = await prisma.donante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DonanteCreateManyArgs>(args?: SelectSubset<T, DonanteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Donantes and returns the data saved in the database.
     * @param {DonanteCreateManyAndReturnArgs} args - Arguments to create many Donantes.
     * @example
     * // Create many Donantes
     * const donante = await prisma.donante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Donantes and only return the `id`
     * const donanteWithIdOnly = await prisma.donante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DonanteCreateManyAndReturnArgs>(args?: SelectSubset<T, DonanteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Donante.
     * @param {DonanteDeleteArgs} args - Arguments to delete one Donante.
     * @example
     * // Delete one Donante
     * const Donante = await prisma.donante.delete({
     *   where: {
     *     // ... filter to delete one Donante
     *   }
     * })
     * 
     */
    delete<T extends DonanteDeleteArgs>(args: SelectSubset<T, DonanteDeleteArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Donante.
     * @param {DonanteUpdateArgs} args - Arguments to update one Donante.
     * @example
     * // Update one Donante
     * const donante = await prisma.donante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DonanteUpdateArgs>(args: SelectSubset<T, DonanteUpdateArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Donantes.
     * @param {DonanteDeleteManyArgs} args - Arguments to filter Donantes to delete.
     * @example
     * // Delete a few Donantes
     * const { count } = await prisma.donante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DonanteDeleteManyArgs>(args?: SelectSubset<T, DonanteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonanteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donantes
     * const donante = await prisma.donante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DonanteUpdateManyArgs>(args: SelectSubset<T, DonanteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donantes and returns the data updated in the database.
     * @param {DonanteUpdateManyAndReturnArgs} args - Arguments to update many Donantes.
     * @example
     * // Update many Donantes
     * const donante = await prisma.donante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Donantes and only return the `id`
     * const donanteWithIdOnly = await prisma.donante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DonanteUpdateManyAndReturnArgs>(args: SelectSubset<T, DonanteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Donante.
     * @param {DonanteUpsertArgs} args - Arguments to update or create a Donante.
     * @example
     * // Update or create a Donante
     * const donante = await prisma.donante.upsert({
     *   create: {
     *     // ... data to create a Donante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donante we want to update
     *   }
     * })
     */
    upsert<T extends DonanteUpsertArgs>(args: SelectSubset<T, DonanteUpsertArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Donantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonanteCountArgs} args - Arguments to filter Donantes to count.
     * @example
     * // Count the number of Donantes
     * const count = await prisma.donante.count({
     *   where: {
     *     // ... the filter for the Donantes we want to count
     *   }
     * })
    **/
    count<T extends DonanteCountArgs>(
      args?: Subset<T, DonanteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonanteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonanteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonanteAggregateArgs>(args: Subset<T, DonanteAggregateArgs>): Prisma.PrismaPromise<GetDonanteAggregateType<T>>

    /**
     * Group by Donante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonanteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonanteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonanteGroupByArgs['orderBy'] }
        : { orderBy?: DonanteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonanteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonanteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donante model
   */
  readonly fields: DonanteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonanteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    donaciones<T extends Donante$donacionesArgs<ExtArgs> = {}>(args?: Subset<T, Donante$donacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Donante model
   */
  interface DonanteFieldRefs {
    readonly id: FieldRef<"Donante", 'Int'>
    readonly dni: FieldRef<"Donante", 'String'>
    readonly nombre: FieldRef<"Donante", 'String'>
    readonly apellido: FieldRef<"Donante", 'String'>
    readonly email: FieldRef<"Donante", 'String'>
    readonly password: FieldRef<"Donante", 'String'>
    readonly createdAt: FieldRef<"Donante", 'DateTime'>
    readonly isActive: FieldRef<"Donante", 'Boolean'>
    readonly grupo_sanguineo: FieldRef<"Donante", 'GrupoSanguineo'>
    readonly factor_rh: FieldRef<"Donante", 'FatorRH'>
    readonly fecha_nacimiento: FieldRef<"Donante", 'DateTime'>
    readonly sexo: FieldRef<"Donante", 'Sexo'>
    readonly fecha_ultima_donacion: FieldRef<"Donante", 'DateTime'>
    readonly estado: FieldRef<"Donante", 'EstadoDonante'>
  }
    

  // Custom InputTypes
  /**
   * Donante findUnique
   */
  export type DonanteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * Filter, which Donante to fetch.
     */
    where: DonanteWhereUniqueInput
  }

  /**
   * Donante findUniqueOrThrow
   */
  export type DonanteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * Filter, which Donante to fetch.
     */
    where: DonanteWhereUniqueInput
  }

  /**
   * Donante findFirst
   */
  export type DonanteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * Filter, which Donante to fetch.
     */
    where?: DonanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donantes to fetch.
     */
    orderBy?: DonanteOrderByWithRelationInput | DonanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donantes.
     */
    cursor?: DonanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donantes.
     */
    distinct?: DonanteScalarFieldEnum | DonanteScalarFieldEnum[]
  }

  /**
   * Donante findFirstOrThrow
   */
  export type DonanteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * Filter, which Donante to fetch.
     */
    where?: DonanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donantes to fetch.
     */
    orderBy?: DonanteOrderByWithRelationInput | DonanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donantes.
     */
    cursor?: DonanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donantes.
     */
    distinct?: DonanteScalarFieldEnum | DonanteScalarFieldEnum[]
  }

  /**
   * Donante findMany
   */
  export type DonanteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * Filter, which Donantes to fetch.
     */
    where?: DonanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donantes to fetch.
     */
    orderBy?: DonanteOrderByWithRelationInput | DonanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donantes.
     */
    cursor?: DonanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donantes.
     */
    skip?: number
    distinct?: DonanteScalarFieldEnum | DonanteScalarFieldEnum[]
  }

  /**
   * Donante create
   */
  export type DonanteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * The data needed to create a Donante.
     */
    data: XOR<DonanteCreateInput, DonanteUncheckedCreateInput>
  }

  /**
   * Donante createMany
   */
  export type DonanteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donantes.
     */
    data: DonanteCreateManyInput | DonanteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Donante createManyAndReturn
   */
  export type DonanteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * The data used to create many Donantes.
     */
    data: DonanteCreateManyInput | DonanteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Donante update
   */
  export type DonanteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * The data needed to update a Donante.
     */
    data: XOR<DonanteUpdateInput, DonanteUncheckedUpdateInput>
    /**
     * Choose, which Donante to update.
     */
    where: DonanteWhereUniqueInput
  }

  /**
   * Donante updateMany
   */
  export type DonanteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donantes.
     */
    data: XOR<DonanteUpdateManyMutationInput, DonanteUncheckedUpdateManyInput>
    /**
     * Filter which Donantes to update
     */
    where?: DonanteWhereInput
    /**
     * Limit how many Donantes to update.
     */
    limit?: number
  }

  /**
   * Donante updateManyAndReturn
   */
  export type DonanteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * The data used to update Donantes.
     */
    data: XOR<DonanteUpdateManyMutationInput, DonanteUncheckedUpdateManyInput>
    /**
     * Filter which Donantes to update
     */
    where?: DonanteWhereInput
    /**
     * Limit how many Donantes to update.
     */
    limit?: number
  }

  /**
   * Donante upsert
   */
  export type DonanteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * The filter to search for the Donante to update in case it exists.
     */
    where: DonanteWhereUniqueInput
    /**
     * In case the Donante found by the `where` argument doesn't exist, create a new Donante with this data.
     */
    create: XOR<DonanteCreateInput, DonanteUncheckedCreateInput>
    /**
     * In case the Donante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonanteUpdateInput, DonanteUncheckedUpdateInput>
  }

  /**
   * Donante delete
   */
  export type DonanteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
    /**
     * Filter which Donante to delete.
     */
    where: DonanteWhereUniqueInput
  }

  /**
   * Donante deleteMany
   */
  export type DonanteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donantes to delete
     */
    where?: DonanteWhereInput
    /**
     * Limit how many Donantes to delete.
     */
    limit?: number
  }

  /**
   * Donante.donaciones
   */
  export type Donante$donacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    where?: DonacionWhereInput
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    cursor?: DonacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Donante without action
   */
  export type DonanteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donante
     */
    select?: DonanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donante
     */
    omit?: DonanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonanteInclude<ExtArgs> | null
  }


  /**
   * Model Campania
   */

  export type AggregateCampania = {
    _count: CampaniaCountAggregateOutputType | null
    _avg: CampaniaAvgAggregateOutputType | null
    _sum: CampaniaSumAggregateOutputType | null
    _min: CampaniaMinAggregateOutputType | null
    _max: CampaniaMaxAggregateOutputType | null
  }

  export type CampaniaAvgAggregateOutputType = {
    id: number | null
    hospitalId: number | null
  }

  export type CampaniaSumAggregateOutputType = {
    id: number | null
    hospitalId: number | null
  }

  export type CampaniaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    ubicacion: string | null
    hospitalId: number | null
  }

  export type CampaniaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    fecha_inicio: Date | null
    fecha_fin: Date | null
    ubicacion: string | null
    hospitalId: number | null
  }

  export type CampaniaCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    fecha_inicio: number
    fecha_fin: number
    ubicacion: number
    hospitalId: number
    _all: number
  }


  export type CampaniaAvgAggregateInputType = {
    id?: true
    hospitalId?: true
  }

  export type CampaniaSumAggregateInputType = {
    id?: true
    hospitalId?: true
  }

  export type CampaniaMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_fin?: true
    ubicacion?: true
    hospitalId?: true
  }

  export type CampaniaMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_fin?: true
    ubicacion?: true
    hospitalId?: true
  }

  export type CampaniaCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fecha_inicio?: true
    fecha_fin?: true
    ubicacion?: true
    hospitalId?: true
    _all?: true
  }

  export type CampaniaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campania to aggregate.
     */
    where?: CampaniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campanias to fetch.
     */
    orderBy?: CampaniaOrderByWithRelationInput | CampaniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campanias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campanias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campanias
    **/
    _count?: true | CampaniaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaniaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaniaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaniaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaniaMaxAggregateInputType
  }

  export type GetCampaniaAggregateType<T extends CampaniaAggregateArgs> = {
        [P in keyof T & keyof AggregateCampania]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampania[P]>
      : GetScalarType<T[P], AggregateCampania[P]>
  }




  export type CampaniaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaniaWhereInput
    orderBy?: CampaniaOrderByWithAggregationInput | CampaniaOrderByWithAggregationInput[]
    by: CampaniaScalarFieldEnum[] | CampaniaScalarFieldEnum
    having?: CampaniaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaniaCountAggregateInputType | true
    _avg?: CampaniaAvgAggregateInputType
    _sum?: CampaniaSumAggregateInputType
    _min?: CampaniaMinAggregateInputType
    _max?: CampaniaMaxAggregateInputType
  }

  export type CampaniaGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    fecha_inicio: Date
    fecha_fin: Date | null
    ubicacion: string
    hospitalId: number
    _count: CampaniaCountAggregateOutputType | null
    _avg: CampaniaAvgAggregateOutputType | null
    _sum: CampaniaSumAggregateOutputType | null
    _min: CampaniaMinAggregateOutputType | null
    _max: CampaniaMaxAggregateOutputType | null
  }

  type GetCampaniaGroupByPayload<T extends CampaniaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaniaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaniaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaniaGroupByOutputType[P]>
            : GetScalarType<T[P], CampaniaGroupByOutputType[P]>
        }
      >
    >


  export type CampaniaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    ubicacion?: boolean
    hospitalId?: boolean
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    donaciones?: boolean | Campania$donacionesArgs<ExtArgs>
    _count?: boolean | CampaniaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campania"]>

  export type CampaniaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    ubicacion?: boolean
    hospitalId?: boolean
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campania"]>

  export type CampaniaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    ubicacion?: boolean
    hospitalId?: boolean
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campania"]>

  export type CampaniaSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fecha_inicio?: boolean
    fecha_fin?: boolean
    ubicacion?: boolean
    hospitalId?: boolean
  }

  export type CampaniaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "fecha_inicio" | "fecha_fin" | "ubicacion" | "hospitalId", ExtArgs["result"]["campania"]>
  export type CampaniaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
    donaciones?: boolean | Campania$donacionesArgs<ExtArgs>
    _count?: boolean | CampaniaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaniaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }
  export type CampaniaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospital?: boolean | HospitalDefaultArgs<ExtArgs>
  }

  export type $CampaniaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campania"
    objects: {
      hospital: Prisma.$HospitalPayload<ExtArgs>
      donaciones: Prisma.$DonacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      fecha_inicio: Date
      fecha_fin: Date | null
      ubicacion: string
      hospitalId: number
    }, ExtArgs["result"]["campania"]>
    composites: {}
  }

  type CampaniaGetPayload<S extends boolean | null | undefined | CampaniaDefaultArgs> = $Result.GetResult<Prisma.$CampaniaPayload, S>

  type CampaniaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaniaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaniaCountAggregateInputType | true
    }

  export interface CampaniaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campania'], meta: { name: 'Campania' } }
    /**
     * Find zero or one Campania that matches the filter.
     * @param {CampaniaFindUniqueArgs} args - Arguments to find a Campania
     * @example
     * // Get one Campania
     * const campania = await prisma.campania.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaniaFindUniqueArgs>(args: SelectSubset<T, CampaniaFindUniqueArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campania that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaniaFindUniqueOrThrowArgs} args - Arguments to find a Campania
     * @example
     * // Get one Campania
     * const campania = await prisma.campania.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaniaFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaniaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campania that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaniaFindFirstArgs} args - Arguments to find a Campania
     * @example
     * // Get one Campania
     * const campania = await prisma.campania.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaniaFindFirstArgs>(args?: SelectSubset<T, CampaniaFindFirstArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campania that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaniaFindFirstOrThrowArgs} args - Arguments to find a Campania
     * @example
     * // Get one Campania
     * const campania = await prisma.campania.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaniaFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaniaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campanias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaniaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campanias
     * const campanias = await prisma.campania.findMany()
     * 
     * // Get first 10 Campanias
     * const campanias = await prisma.campania.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaniaWithIdOnly = await prisma.campania.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaniaFindManyArgs>(args?: SelectSubset<T, CampaniaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campania.
     * @param {CampaniaCreateArgs} args - Arguments to create a Campania.
     * @example
     * // Create one Campania
     * const Campania = await prisma.campania.create({
     *   data: {
     *     // ... data to create a Campania
     *   }
     * })
     * 
     */
    create<T extends CampaniaCreateArgs>(args: SelectSubset<T, CampaniaCreateArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campanias.
     * @param {CampaniaCreateManyArgs} args - Arguments to create many Campanias.
     * @example
     * // Create many Campanias
     * const campania = await prisma.campania.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaniaCreateManyArgs>(args?: SelectSubset<T, CampaniaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campanias and returns the data saved in the database.
     * @param {CampaniaCreateManyAndReturnArgs} args - Arguments to create many Campanias.
     * @example
     * // Create many Campanias
     * const campania = await prisma.campania.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campanias and only return the `id`
     * const campaniaWithIdOnly = await prisma.campania.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaniaCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaniaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campania.
     * @param {CampaniaDeleteArgs} args - Arguments to delete one Campania.
     * @example
     * // Delete one Campania
     * const Campania = await prisma.campania.delete({
     *   where: {
     *     // ... filter to delete one Campania
     *   }
     * })
     * 
     */
    delete<T extends CampaniaDeleteArgs>(args: SelectSubset<T, CampaniaDeleteArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campania.
     * @param {CampaniaUpdateArgs} args - Arguments to update one Campania.
     * @example
     * // Update one Campania
     * const campania = await prisma.campania.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaniaUpdateArgs>(args: SelectSubset<T, CampaniaUpdateArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campanias.
     * @param {CampaniaDeleteManyArgs} args - Arguments to filter Campanias to delete.
     * @example
     * // Delete a few Campanias
     * const { count } = await prisma.campania.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaniaDeleteManyArgs>(args?: SelectSubset<T, CampaniaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaniaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campanias
     * const campania = await prisma.campania.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaniaUpdateManyArgs>(args: SelectSubset<T, CampaniaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campanias and returns the data updated in the database.
     * @param {CampaniaUpdateManyAndReturnArgs} args - Arguments to update many Campanias.
     * @example
     * // Update many Campanias
     * const campania = await prisma.campania.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campanias and only return the `id`
     * const campaniaWithIdOnly = await prisma.campania.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaniaUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaniaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campania.
     * @param {CampaniaUpsertArgs} args - Arguments to update or create a Campania.
     * @example
     * // Update or create a Campania
     * const campania = await prisma.campania.upsert({
     *   create: {
     *     // ... data to create a Campania
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campania we want to update
     *   }
     * })
     */
    upsert<T extends CampaniaUpsertArgs>(args: SelectSubset<T, CampaniaUpsertArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campanias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaniaCountArgs} args - Arguments to filter Campanias to count.
     * @example
     * // Count the number of Campanias
     * const count = await prisma.campania.count({
     *   where: {
     *     // ... the filter for the Campanias we want to count
     *   }
     * })
    **/
    count<T extends CampaniaCountArgs>(
      args?: Subset<T, CampaniaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaniaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campania.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaniaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaniaAggregateArgs>(args: Subset<T, CampaniaAggregateArgs>): Prisma.PrismaPromise<GetCampaniaAggregateType<T>>

    /**
     * Group by Campania.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaniaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaniaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaniaGroupByArgs['orderBy'] }
        : { orderBy?: CampaniaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaniaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaniaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campania model
   */
  readonly fields: CampaniaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campania.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaniaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hospital<T extends HospitalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalDefaultArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    donaciones<T extends Campania$donacionesArgs<ExtArgs> = {}>(args?: Subset<T, Campania$donacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campania model
   */
  interface CampaniaFieldRefs {
    readonly id: FieldRef<"Campania", 'Int'>
    readonly nombre: FieldRef<"Campania", 'String'>
    readonly descripcion: FieldRef<"Campania", 'String'>
    readonly fecha_inicio: FieldRef<"Campania", 'DateTime'>
    readonly fecha_fin: FieldRef<"Campania", 'DateTime'>
    readonly ubicacion: FieldRef<"Campania", 'String'>
    readonly hospitalId: FieldRef<"Campania", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Campania findUnique
   */
  export type CampaniaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * Filter, which Campania to fetch.
     */
    where: CampaniaWhereUniqueInput
  }

  /**
   * Campania findUniqueOrThrow
   */
  export type CampaniaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * Filter, which Campania to fetch.
     */
    where: CampaniaWhereUniqueInput
  }

  /**
   * Campania findFirst
   */
  export type CampaniaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * Filter, which Campania to fetch.
     */
    where?: CampaniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campanias to fetch.
     */
    orderBy?: CampaniaOrderByWithRelationInput | CampaniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campanias.
     */
    cursor?: CampaniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campanias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campanias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campanias.
     */
    distinct?: CampaniaScalarFieldEnum | CampaniaScalarFieldEnum[]
  }

  /**
   * Campania findFirstOrThrow
   */
  export type CampaniaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * Filter, which Campania to fetch.
     */
    where?: CampaniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campanias to fetch.
     */
    orderBy?: CampaniaOrderByWithRelationInput | CampaniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campanias.
     */
    cursor?: CampaniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campanias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campanias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campanias.
     */
    distinct?: CampaniaScalarFieldEnum | CampaniaScalarFieldEnum[]
  }

  /**
   * Campania findMany
   */
  export type CampaniaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * Filter, which Campanias to fetch.
     */
    where?: CampaniaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campanias to fetch.
     */
    orderBy?: CampaniaOrderByWithRelationInput | CampaniaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campanias.
     */
    cursor?: CampaniaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campanias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campanias.
     */
    skip?: number
    distinct?: CampaniaScalarFieldEnum | CampaniaScalarFieldEnum[]
  }

  /**
   * Campania create
   */
  export type CampaniaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * The data needed to create a Campania.
     */
    data: XOR<CampaniaCreateInput, CampaniaUncheckedCreateInput>
  }

  /**
   * Campania createMany
   */
  export type CampaniaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campanias.
     */
    data: CampaniaCreateManyInput | CampaniaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campania createManyAndReturn
   */
  export type CampaniaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * The data used to create many Campanias.
     */
    data: CampaniaCreateManyInput | CampaniaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campania update
   */
  export type CampaniaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * The data needed to update a Campania.
     */
    data: XOR<CampaniaUpdateInput, CampaniaUncheckedUpdateInput>
    /**
     * Choose, which Campania to update.
     */
    where: CampaniaWhereUniqueInput
  }

  /**
   * Campania updateMany
   */
  export type CampaniaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campanias.
     */
    data: XOR<CampaniaUpdateManyMutationInput, CampaniaUncheckedUpdateManyInput>
    /**
     * Filter which Campanias to update
     */
    where?: CampaniaWhereInput
    /**
     * Limit how many Campanias to update.
     */
    limit?: number
  }

  /**
   * Campania updateManyAndReturn
   */
  export type CampaniaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * The data used to update Campanias.
     */
    data: XOR<CampaniaUpdateManyMutationInput, CampaniaUncheckedUpdateManyInput>
    /**
     * Filter which Campanias to update
     */
    where?: CampaniaWhereInput
    /**
     * Limit how many Campanias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campania upsert
   */
  export type CampaniaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * The filter to search for the Campania to update in case it exists.
     */
    where: CampaniaWhereUniqueInput
    /**
     * In case the Campania found by the `where` argument doesn't exist, create a new Campania with this data.
     */
    create: XOR<CampaniaCreateInput, CampaniaUncheckedCreateInput>
    /**
     * In case the Campania was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaniaUpdateInput, CampaniaUncheckedUpdateInput>
  }

  /**
   * Campania delete
   */
  export type CampaniaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    /**
     * Filter which Campania to delete.
     */
    where: CampaniaWhereUniqueInput
  }

  /**
   * Campania deleteMany
   */
  export type CampaniaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campanias to delete
     */
    where?: CampaniaWhereInput
    /**
     * Limit how many Campanias to delete.
     */
    limit?: number
  }

  /**
   * Campania.donaciones
   */
  export type Campania$donacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    where?: DonacionWhereInput
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    cursor?: DonacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Campania without action
   */
  export type CampaniaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
  }


  /**
   * Model Hospital
   */

  export type AggregateHospital = {
    _count: HospitalCountAggregateOutputType | null
    _avg: HospitalAvgAggregateOutputType | null
    _sum: HospitalSumAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  export type HospitalAvgAggregateOutputType = {
    id: number | null
    numero: number | null
    telefono: number | null
  }

  export type HospitalSumAggregateOutputType = {
    id: number | null
    numero: number | null
    telefono: bigint | null
  }

  export type HospitalMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    direccion: string | null
    numero: number | null
    telefono: bigint | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type HospitalMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    direccion: string | null
    numero: number | null
    telefono: bigint | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type HospitalCountAggregateOutputType = {
    id: number
    nombre: number
    direccion: number
    numero: number
    telefono: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type HospitalAvgAggregateInputType = {
    id?: true
    numero?: true
    telefono?: true
  }

  export type HospitalSumAggregateInputType = {
    id?: true
    numero?: true
    telefono?: true
  }

  export type HospitalMinAggregateInputType = {
    id?: true
    nombre?: true
    direccion?: true
    numero?: true
    telefono?: true
    isActive?: true
    createdAt?: true
  }

  export type HospitalMaxAggregateInputType = {
    id?: true
    nombre?: true
    direccion?: true
    numero?: true
    telefono?: true
    isActive?: true
    createdAt?: true
  }

  export type HospitalCountAggregateInputType = {
    id?: true
    nombre?: true
    direccion?: true
    numero?: true
    telefono?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type HospitalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospital to aggregate.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hospitals
    **/
    _count?: true | HospitalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HospitalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HospitalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalMaxAggregateInputType
  }

  export type GetHospitalAggregateType<T extends HospitalAggregateArgs> = {
        [P in keyof T & keyof AggregateHospital]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospital[P]>
      : GetScalarType<T[P], AggregateHospital[P]>
  }




  export type HospitalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalWhereInput
    orderBy?: HospitalOrderByWithAggregationInput | HospitalOrderByWithAggregationInput[]
    by: HospitalScalarFieldEnum[] | HospitalScalarFieldEnum
    having?: HospitalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalCountAggregateInputType | true
    _avg?: HospitalAvgAggregateInputType
    _sum?: HospitalSumAggregateInputType
    _min?: HospitalMinAggregateInputType
    _max?: HospitalMaxAggregateInputType
  }

  export type HospitalGroupByOutputType = {
    id: number
    nombre: string
    direccion: string
    numero: number
    telefono: bigint
    isActive: boolean
    createdAt: Date
    _count: HospitalCountAggregateOutputType | null
    _avg: HospitalAvgAggregateOutputType | null
    _sum: HospitalSumAggregateOutputType | null
    _min: HospitalMinAggregateOutputType | null
    _max: HospitalMaxAggregateOutputType | null
  }

  type GetHospitalGroupByPayload<T extends HospitalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospitalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalGroupByOutputType[P]>
        }
      >
    >


  export type HospitalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    direccion?: boolean
    numero?: boolean
    telefono?: boolean
    isActive?: boolean
    createdAt?: boolean
    campanias?: boolean | Hospital$campaniasArgs<ExtArgs>
    donaciones?: boolean | Hospital$donacionesArgs<ExtArgs>
    _count?: boolean | HospitalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    direccion?: boolean
    numero?: boolean
    telefono?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    direccion?: boolean
    numero?: boolean
    telefono?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["hospital"]>

  export type HospitalSelectScalar = {
    id?: boolean
    nombre?: boolean
    direccion?: boolean
    numero?: boolean
    telefono?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type HospitalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "direccion" | "numero" | "telefono" | "isActive" | "createdAt", ExtArgs["result"]["hospital"]>
  export type HospitalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campanias?: boolean | Hospital$campaniasArgs<ExtArgs>
    donaciones?: boolean | Hospital$donacionesArgs<ExtArgs>
    _count?: boolean | HospitalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HospitalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HospitalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HospitalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hospital"
    objects: {
      campanias: Prisma.$CampaniaPayload<ExtArgs>[]
      donaciones: Prisma.$DonacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      direccion: string
      numero: number
      telefono: bigint
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["hospital"]>
    composites: {}
  }

  type HospitalGetPayload<S extends boolean | null | undefined | HospitalDefaultArgs> = $Result.GetResult<Prisma.$HospitalPayload, S>

  type HospitalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HospitalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HospitalCountAggregateInputType | true
    }

  export interface HospitalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hospital'], meta: { name: 'Hospital' } }
    /**
     * Find zero or one Hospital that matches the filter.
     * @param {HospitalFindUniqueArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalFindUniqueArgs>(args: SelectSubset<T, HospitalFindUniqueArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hospital that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HospitalFindUniqueOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hospital that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalFindFirstArgs>(args?: SelectSubset<T, HospitalFindFirstArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hospital that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindFirstOrThrowArgs} args - Arguments to find a Hospital
     * @example
     * // Get one Hospital
     * const hospital = await prisma.hospital.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hospitals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospitals
     * const hospitals = await prisma.hospital.findMany()
     * 
     * // Get first 10 Hospitals
     * const hospitals = await prisma.hospital.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalWithIdOnly = await prisma.hospital.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HospitalFindManyArgs>(args?: SelectSubset<T, HospitalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hospital.
     * @param {HospitalCreateArgs} args - Arguments to create a Hospital.
     * @example
     * // Create one Hospital
     * const Hospital = await prisma.hospital.create({
     *   data: {
     *     // ... data to create a Hospital
     *   }
     * })
     * 
     */
    create<T extends HospitalCreateArgs>(args: SelectSubset<T, HospitalCreateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hospitals.
     * @param {HospitalCreateManyArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HospitalCreateManyArgs>(args?: SelectSubset<T, HospitalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hospitals and returns the data saved in the database.
     * @param {HospitalCreateManyAndReturnArgs} args - Arguments to create many Hospitals.
     * @example
     * // Create many Hospitals
     * const hospital = await prisma.hospital.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hospitals and only return the `id`
     * const hospitalWithIdOnly = await prisma.hospital.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HospitalCreateManyAndReturnArgs>(args?: SelectSubset<T, HospitalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hospital.
     * @param {HospitalDeleteArgs} args - Arguments to delete one Hospital.
     * @example
     * // Delete one Hospital
     * const Hospital = await prisma.hospital.delete({
     *   where: {
     *     // ... filter to delete one Hospital
     *   }
     * })
     * 
     */
    delete<T extends HospitalDeleteArgs>(args: SelectSubset<T, HospitalDeleteArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hospital.
     * @param {HospitalUpdateArgs} args - Arguments to update one Hospital.
     * @example
     * // Update one Hospital
     * const hospital = await prisma.hospital.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HospitalUpdateArgs>(args: SelectSubset<T, HospitalUpdateArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hospitals.
     * @param {HospitalDeleteManyArgs} args - Arguments to filter Hospitals to delete.
     * @example
     * // Delete a few Hospitals
     * const { count } = await prisma.hospital.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HospitalDeleteManyArgs>(args?: SelectSubset<T, HospitalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HospitalUpdateManyArgs>(args: SelectSubset<T, HospitalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitals and returns the data updated in the database.
     * @param {HospitalUpdateManyAndReturnArgs} args - Arguments to update many Hospitals.
     * @example
     * // Update many Hospitals
     * const hospital = await prisma.hospital.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hospitals and only return the `id`
     * const hospitalWithIdOnly = await prisma.hospital.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HospitalUpdateManyAndReturnArgs>(args: SelectSubset<T, HospitalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hospital.
     * @param {HospitalUpsertArgs} args - Arguments to update or create a Hospital.
     * @example
     * // Update or create a Hospital
     * const hospital = await prisma.hospital.upsert({
     *   create: {
     *     // ... data to create a Hospital
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospital we want to update
     *   }
     * })
     */
    upsert<T extends HospitalUpsertArgs>(args: SelectSubset<T, HospitalUpsertArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hospitals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalCountArgs} args - Arguments to filter Hospitals to count.
     * @example
     * // Count the number of Hospitals
     * const count = await prisma.hospital.count({
     *   where: {
     *     // ... the filter for the Hospitals we want to count
     *   }
     * })
    **/
    count<T extends HospitalCountArgs>(
      args?: Subset<T, HospitalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalAggregateArgs>(args: Subset<T, HospitalAggregateArgs>): Prisma.PrismaPromise<GetHospitalAggregateType<T>>

    /**
     * Group by Hospital.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalGroupByArgs['orderBy'] }
        : { orderBy?: HospitalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hospital model
   */
  readonly fields: HospitalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hospital.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HospitalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campanias<T extends Hospital$campaniasArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$campaniasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    donaciones<T extends Hospital$donacionesArgs<ExtArgs> = {}>(args?: Subset<T, Hospital$donacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hospital model
   */
  interface HospitalFieldRefs {
    readonly id: FieldRef<"Hospital", 'Int'>
    readonly nombre: FieldRef<"Hospital", 'String'>
    readonly direccion: FieldRef<"Hospital", 'String'>
    readonly numero: FieldRef<"Hospital", 'Int'>
    readonly telefono: FieldRef<"Hospital", 'BigInt'>
    readonly isActive: FieldRef<"Hospital", 'Boolean'>
    readonly createdAt: FieldRef<"Hospital", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hospital findUnique
   */
  export type HospitalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findUniqueOrThrow
   */
  export type HospitalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital findFirst
   */
  export type HospitalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findFirstOrThrow
   */
  export type HospitalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospital to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitals.
     */
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital findMany
   */
  export type HospitalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter, which Hospitals to fetch.
     */
    where?: HospitalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitals to fetch.
     */
    orderBy?: HospitalOrderByWithRelationInput | HospitalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hospitals.
     */
    cursor?: HospitalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitals.
     */
    skip?: number
    distinct?: HospitalScalarFieldEnum | HospitalScalarFieldEnum[]
  }

  /**
   * Hospital create
   */
  export type HospitalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The data needed to create a Hospital.
     */
    data: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
  }

  /**
   * Hospital createMany
   */
  export type HospitalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospital createManyAndReturn
   */
  export type HospitalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * The data used to create many Hospitals.
     */
    data: HospitalCreateManyInput | HospitalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospital update
   */
  export type HospitalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The data needed to update a Hospital.
     */
    data: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
    /**
     * Choose, which Hospital to update.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital updateMany
   */
  export type HospitalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput
    /**
     * Limit how many Hospitals to update.
     */
    limit?: number
  }

  /**
   * Hospital updateManyAndReturn
   */
  export type HospitalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * The data used to update Hospitals.
     */
    data: XOR<HospitalUpdateManyMutationInput, HospitalUncheckedUpdateManyInput>
    /**
     * Filter which Hospitals to update
     */
    where?: HospitalWhereInput
    /**
     * Limit how many Hospitals to update.
     */
    limit?: number
  }

  /**
   * Hospital upsert
   */
  export type HospitalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * The filter to search for the Hospital to update in case it exists.
     */
    where: HospitalWhereUniqueInput
    /**
     * In case the Hospital found by the `where` argument doesn't exist, create a new Hospital with this data.
     */
    create: XOR<HospitalCreateInput, HospitalUncheckedCreateInput>
    /**
     * In case the Hospital was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalUpdateInput, HospitalUncheckedUpdateInput>
  }

  /**
   * Hospital delete
   */
  export type HospitalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    /**
     * Filter which Hospital to delete.
     */
    where: HospitalWhereUniqueInput
  }

  /**
   * Hospital deleteMany
   */
  export type HospitalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospitals to delete
     */
    where?: HospitalWhereInput
    /**
     * Limit how many Hospitals to delete.
     */
    limit?: number
  }

  /**
   * Hospital.campanias
   */
  export type Hospital$campaniasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    where?: CampaniaWhereInput
    orderBy?: CampaniaOrderByWithRelationInput | CampaniaOrderByWithRelationInput[]
    cursor?: CampaniaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaniaScalarFieldEnum | CampaniaScalarFieldEnum[]
  }

  /**
   * Hospital.donaciones
   */
  export type Hospital$donacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    where?: DonacionWhereInput
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    cursor?: DonacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Hospital without action
   */
  export type HospitalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
  }


  /**
   * Model Donacion
   */

  export type AggregateDonacion = {
    _count: DonacionCountAggregateOutputType | null
    _avg: DonacionAvgAggregateOutputType | null
    _sum: DonacionSumAggregateOutputType | null
    _min: DonacionMinAggregateOutputType | null
    _max: DonacionMaxAggregateOutputType | null
  }

  export type DonacionAvgAggregateOutputType = {
    id: number | null
    DonanteId: number | null
    campaniaId: number | null
    hospitalId: number | null
  }

  export type DonacionSumAggregateOutputType = {
    id: number | null
    DonanteId: number | null
    campaniaId: number | null
    hospitalId: number | null
  }

  export type DonacionMinAggregateOutputType = {
    id: number | null
    fecha_donacion: Date | null
    tipo_donacion: $Enums.TipoDonacion | null
    estado: $Enums.EstadoDonacion | null
    DonanteId: number | null
    campaniaId: number | null
    hospitalId: number | null
  }

  export type DonacionMaxAggregateOutputType = {
    id: number | null
    fecha_donacion: Date | null
    tipo_donacion: $Enums.TipoDonacion | null
    estado: $Enums.EstadoDonacion | null
    DonanteId: number | null
    campaniaId: number | null
    hospitalId: number | null
  }

  export type DonacionCountAggregateOutputType = {
    id: number
    fecha_donacion: number
    tipo_donacion: number
    estado: number
    DonanteId: number
    campaniaId: number
    hospitalId: number
    _all: number
  }


  export type DonacionAvgAggregateInputType = {
    id?: true
    DonanteId?: true
    campaniaId?: true
    hospitalId?: true
  }

  export type DonacionSumAggregateInputType = {
    id?: true
    DonanteId?: true
    campaniaId?: true
    hospitalId?: true
  }

  export type DonacionMinAggregateInputType = {
    id?: true
    fecha_donacion?: true
    tipo_donacion?: true
    estado?: true
    DonanteId?: true
    campaniaId?: true
    hospitalId?: true
  }

  export type DonacionMaxAggregateInputType = {
    id?: true
    fecha_donacion?: true
    tipo_donacion?: true
    estado?: true
    DonanteId?: true
    campaniaId?: true
    hospitalId?: true
  }

  export type DonacionCountAggregateInputType = {
    id?: true
    fecha_donacion?: true
    tipo_donacion?: true
    estado?: true
    DonanteId?: true
    campaniaId?: true
    hospitalId?: true
    _all?: true
  }

  export type DonacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donacion to aggregate.
     */
    where?: DonacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donacions to fetch.
     */
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donacions
    **/
    _count?: true | DonacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonacionMaxAggregateInputType
  }

  export type GetDonacionAggregateType<T extends DonacionAggregateArgs> = {
        [P in keyof T & keyof AggregateDonacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonacion[P]>
      : GetScalarType<T[P], AggregateDonacion[P]>
  }




  export type DonacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonacionWhereInput
    orderBy?: DonacionOrderByWithAggregationInput | DonacionOrderByWithAggregationInput[]
    by: DonacionScalarFieldEnum[] | DonacionScalarFieldEnum
    having?: DonacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonacionCountAggregateInputType | true
    _avg?: DonacionAvgAggregateInputType
    _sum?: DonacionSumAggregateInputType
    _min?: DonacionMinAggregateInputType
    _max?: DonacionMaxAggregateInputType
  }

  export type DonacionGroupByOutputType = {
    id: number
    fecha_donacion: Date
    tipo_donacion: $Enums.TipoDonacion
    estado: $Enums.EstadoDonacion
    DonanteId: number
    campaniaId: number | null
    hospitalId: number | null
    _count: DonacionCountAggregateOutputType | null
    _avg: DonacionAvgAggregateOutputType | null
    _sum: DonacionSumAggregateOutputType | null
    _min: DonacionMinAggregateOutputType | null
    _max: DonacionMaxAggregateOutputType | null
  }

  type GetDonacionGroupByPayload<T extends DonacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonacionGroupByOutputType[P]>
            : GetScalarType<T[P], DonacionGroupByOutputType[P]>
        }
      >
    >


  export type DonacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha_donacion?: boolean
    tipo_donacion?: boolean
    estado?: boolean
    DonanteId?: boolean
    campaniaId?: boolean
    hospitalId?: boolean
    donante?: boolean | DonanteDefaultArgs<ExtArgs>
    campania?: boolean | Donacion$campaniaArgs<ExtArgs>
    hospital?: boolean | Donacion$hospitalArgs<ExtArgs>
  }, ExtArgs["result"]["donacion"]>

  export type DonacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha_donacion?: boolean
    tipo_donacion?: boolean
    estado?: boolean
    DonanteId?: boolean
    campaniaId?: boolean
    hospitalId?: boolean
    donante?: boolean | DonanteDefaultArgs<ExtArgs>
    campania?: boolean | Donacion$campaniaArgs<ExtArgs>
    hospital?: boolean | Donacion$hospitalArgs<ExtArgs>
  }, ExtArgs["result"]["donacion"]>

  export type DonacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha_donacion?: boolean
    tipo_donacion?: boolean
    estado?: boolean
    DonanteId?: boolean
    campaniaId?: boolean
    hospitalId?: boolean
    donante?: boolean | DonanteDefaultArgs<ExtArgs>
    campania?: boolean | Donacion$campaniaArgs<ExtArgs>
    hospital?: boolean | Donacion$hospitalArgs<ExtArgs>
  }, ExtArgs["result"]["donacion"]>

  export type DonacionSelectScalar = {
    id?: boolean
    fecha_donacion?: boolean
    tipo_donacion?: boolean
    estado?: boolean
    DonanteId?: boolean
    campaniaId?: boolean
    hospitalId?: boolean
  }

  export type DonacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fecha_donacion" | "tipo_donacion" | "estado" | "DonanteId" | "campaniaId" | "hospitalId", ExtArgs["result"]["donacion"]>
  export type DonacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donante?: boolean | DonanteDefaultArgs<ExtArgs>
    campania?: boolean | Donacion$campaniaArgs<ExtArgs>
    hospital?: boolean | Donacion$hospitalArgs<ExtArgs>
  }
  export type DonacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donante?: boolean | DonanteDefaultArgs<ExtArgs>
    campania?: boolean | Donacion$campaniaArgs<ExtArgs>
    hospital?: boolean | Donacion$hospitalArgs<ExtArgs>
  }
  export type DonacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    donante?: boolean | DonanteDefaultArgs<ExtArgs>
    campania?: boolean | Donacion$campaniaArgs<ExtArgs>
    hospital?: boolean | Donacion$hospitalArgs<ExtArgs>
  }

  export type $DonacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Donacion"
    objects: {
      donante: Prisma.$DonantePayload<ExtArgs>
      campania: Prisma.$CampaniaPayload<ExtArgs> | null
      hospital: Prisma.$HospitalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fecha_donacion: Date
      tipo_donacion: $Enums.TipoDonacion
      estado: $Enums.EstadoDonacion
      DonanteId: number
      campaniaId: number | null
      hospitalId: number | null
    }, ExtArgs["result"]["donacion"]>
    composites: {}
  }

  type DonacionGetPayload<S extends boolean | null | undefined | DonacionDefaultArgs> = $Result.GetResult<Prisma.$DonacionPayload, S>

  type DonacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DonacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DonacionCountAggregateInputType | true
    }

  export interface DonacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donacion'], meta: { name: 'Donacion' } }
    /**
     * Find zero or one Donacion that matches the filter.
     * @param {DonacionFindUniqueArgs} args - Arguments to find a Donacion
     * @example
     * // Get one Donacion
     * const donacion = await prisma.donacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DonacionFindUniqueArgs>(args: SelectSubset<T, DonacionFindUniqueArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Donacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DonacionFindUniqueOrThrowArgs} args - Arguments to find a Donacion
     * @example
     * // Get one Donacion
     * const donacion = await prisma.donacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DonacionFindUniqueOrThrowArgs>(args: SelectSubset<T, DonacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionFindFirstArgs} args - Arguments to find a Donacion
     * @example
     * // Get one Donacion
     * const donacion = await prisma.donacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DonacionFindFirstArgs>(args?: SelectSubset<T, DonacionFindFirstArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionFindFirstOrThrowArgs} args - Arguments to find a Donacion
     * @example
     * // Get one Donacion
     * const donacion = await prisma.donacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DonacionFindFirstOrThrowArgs>(args?: SelectSubset<T, DonacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Donacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donacions
     * const donacions = await prisma.donacion.findMany()
     * 
     * // Get first 10 Donacions
     * const donacions = await prisma.donacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donacionWithIdOnly = await prisma.donacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DonacionFindManyArgs>(args?: SelectSubset<T, DonacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Donacion.
     * @param {DonacionCreateArgs} args - Arguments to create a Donacion.
     * @example
     * // Create one Donacion
     * const Donacion = await prisma.donacion.create({
     *   data: {
     *     // ... data to create a Donacion
     *   }
     * })
     * 
     */
    create<T extends DonacionCreateArgs>(args: SelectSubset<T, DonacionCreateArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Donacions.
     * @param {DonacionCreateManyArgs} args - Arguments to create many Donacions.
     * @example
     * // Create many Donacions
     * const donacion = await prisma.donacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DonacionCreateManyArgs>(args?: SelectSubset<T, DonacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Donacions and returns the data saved in the database.
     * @param {DonacionCreateManyAndReturnArgs} args - Arguments to create many Donacions.
     * @example
     * // Create many Donacions
     * const donacion = await prisma.donacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Donacions and only return the `id`
     * const donacionWithIdOnly = await prisma.donacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DonacionCreateManyAndReturnArgs>(args?: SelectSubset<T, DonacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Donacion.
     * @param {DonacionDeleteArgs} args - Arguments to delete one Donacion.
     * @example
     * // Delete one Donacion
     * const Donacion = await prisma.donacion.delete({
     *   where: {
     *     // ... filter to delete one Donacion
     *   }
     * })
     * 
     */
    delete<T extends DonacionDeleteArgs>(args: SelectSubset<T, DonacionDeleteArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Donacion.
     * @param {DonacionUpdateArgs} args - Arguments to update one Donacion.
     * @example
     * // Update one Donacion
     * const donacion = await prisma.donacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DonacionUpdateArgs>(args: SelectSubset<T, DonacionUpdateArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Donacions.
     * @param {DonacionDeleteManyArgs} args - Arguments to filter Donacions to delete.
     * @example
     * // Delete a few Donacions
     * const { count } = await prisma.donacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DonacionDeleteManyArgs>(args?: SelectSubset<T, DonacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donacions
     * const donacion = await prisma.donacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DonacionUpdateManyArgs>(args: SelectSubset<T, DonacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donacions and returns the data updated in the database.
     * @param {DonacionUpdateManyAndReturnArgs} args - Arguments to update many Donacions.
     * @example
     * // Update many Donacions
     * const donacion = await prisma.donacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Donacions and only return the `id`
     * const donacionWithIdOnly = await prisma.donacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DonacionUpdateManyAndReturnArgs>(args: SelectSubset<T, DonacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Donacion.
     * @param {DonacionUpsertArgs} args - Arguments to update or create a Donacion.
     * @example
     * // Update or create a Donacion
     * const donacion = await prisma.donacion.upsert({
     *   create: {
     *     // ... data to create a Donacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donacion we want to update
     *   }
     * })
     */
    upsert<T extends DonacionUpsertArgs>(args: SelectSubset<T, DonacionUpsertArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Donacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionCountArgs} args - Arguments to filter Donacions to count.
     * @example
     * // Count the number of Donacions
     * const count = await prisma.donacion.count({
     *   where: {
     *     // ... the filter for the Donacions we want to count
     *   }
     * })
    **/
    count<T extends DonacionCountArgs>(
      args?: Subset<T, DonacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonacionAggregateArgs>(args: Subset<T, DonacionAggregateArgs>): Prisma.PrismaPromise<GetDonacionAggregateType<T>>

    /**
     * Group by Donacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonacionGroupByArgs['orderBy'] }
        : { orderBy?: DonacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donacion model
   */
  readonly fields: DonacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    donante<T extends DonanteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DonanteDefaultArgs<ExtArgs>>): Prisma__DonanteClient<$Result.GetResult<Prisma.$DonantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campania<T extends Donacion$campaniaArgs<ExtArgs> = {}>(args?: Subset<T, Donacion$campaniaArgs<ExtArgs>>): Prisma__CampaniaClient<$Result.GetResult<Prisma.$CampaniaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    hospital<T extends Donacion$hospitalArgs<ExtArgs> = {}>(args?: Subset<T, Donacion$hospitalArgs<ExtArgs>>): Prisma__HospitalClient<$Result.GetResult<Prisma.$HospitalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Donacion model
   */
  interface DonacionFieldRefs {
    readonly id: FieldRef<"Donacion", 'Int'>
    readonly fecha_donacion: FieldRef<"Donacion", 'DateTime'>
    readonly tipo_donacion: FieldRef<"Donacion", 'TipoDonacion'>
    readonly estado: FieldRef<"Donacion", 'EstadoDonacion'>
    readonly DonanteId: FieldRef<"Donacion", 'Int'>
    readonly campaniaId: FieldRef<"Donacion", 'Int'>
    readonly hospitalId: FieldRef<"Donacion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Donacion findUnique
   */
  export type DonacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacion to fetch.
     */
    where: DonacionWhereUniqueInput
  }

  /**
   * Donacion findUniqueOrThrow
   */
  export type DonacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacion to fetch.
     */
    where: DonacionWhereUniqueInput
  }

  /**
   * Donacion findFirst
   */
  export type DonacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacion to fetch.
     */
    where?: DonacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donacions to fetch.
     */
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donacions.
     */
    cursor?: DonacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donacions.
     */
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Donacion findFirstOrThrow
   */
  export type DonacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacion to fetch.
     */
    where?: DonacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donacions to fetch.
     */
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donacions.
     */
    cursor?: DonacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donacions.
     */
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Donacion findMany
   */
  export type DonacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacions to fetch.
     */
    where?: DonacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donacions to fetch.
     */
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donacions.
     */
    cursor?: DonacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donacions.
     */
    skip?: number
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Donacion create
   */
  export type DonacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Donacion.
     */
    data: XOR<DonacionCreateInput, DonacionUncheckedCreateInput>
  }

  /**
   * Donacion createMany
   */
  export type DonacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donacions.
     */
    data: DonacionCreateManyInput | DonacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Donacion createManyAndReturn
   */
  export type DonacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * The data used to create many Donacions.
     */
    data: DonacionCreateManyInput | DonacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Donacion update
   */
  export type DonacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Donacion.
     */
    data: XOR<DonacionUpdateInput, DonacionUncheckedUpdateInput>
    /**
     * Choose, which Donacion to update.
     */
    where: DonacionWhereUniqueInput
  }

  /**
   * Donacion updateMany
   */
  export type DonacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donacions.
     */
    data: XOR<DonacionUpdateManyMutationInput, DonacionUncheckedUpdateManyInput>
    /**
     * Filter which Donacions to update
     */
    where?: DonacionWhereInput
    /**
     * Limit how many Donacions to update.
     */
    limit?: number
  }

  /**
   * Donacion updateManyAndReturn
   */
  export type DonacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * The data used to update Donacions.
     */
    data: XOR<DonacionUpdateManyMutationInput, DonacionUncheckedUpdateManyInput>
    /**
     * Filter which Donacions to update
     */
    where?: DonacionWhereInput
    /**
     * Limit how many Donacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Donacion upsert
   */
  export type DonacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Donacion to update in case it exists.
     */
    where: DonacionWhereUniqueInput
    /**
     * In case the Donacion found by the `where` argument doesn't exist, create a new Donacion with this data.
     */
    create: XOR<DonacionCreateInput, DonacionUncheckedCreateInput>
    /**
     * In case the Donacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonacionUpdateInput, DonacionUncheckedUpdateInput>
  }

  /**
   * Donacion delete
   */
  export type DonacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter which Donacion to delete.
     */
    where: DonacionWhereUniqueInput
  }

  /**
   * Donacion deleteMany
   */
  export type DonacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donacions to delete
     */
    where?: DonacionWhereInput
    /**
     * Limit how many Donacions to delete.
     */
    limit?: number
  }

  /**
   * Donacion.campania
   */
  export type Donacion$campaniaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campania
     */
    select?: CampaniaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campania
     */
    omit?: CampaniaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaniaInclude<ExtArgs> | null
    where?: CampaniaWhereInput
  }

  /**
   * Donacion.hospital
   */
  export type Donacion$hospitalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospital
     */
    select?: HospitalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospital
     */
    omit?: HospitalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalInclude<ExtArgs> | null
    where?: HospitalWhereInput
  }

  /**
   * Donacion without action
   */
  export type DonacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DonanteScalarFieldEnum: {
    id: 'id',
    dni: 'dni',
    nombre: 'nombre',
    apellido: 'apellido',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    isActive: 'isActive',
    grupo_sanguineo: 'grupo_sanguineo',
    factor_rh: 'factor_rh',
    fecha_nacimiento: 'fecha_nacimiento',
    sexo: 'sexo',
    fecha_ultima_donacion: 'fecha_ultima_donacion',
    estado: 'estado'
  };

  export type DonanteScalarFieldEnum = (typeof DonanteScalarFieldEnum)[keyof typeof DonanteScalarFieldEnum]


  export const CampaniaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    fecha_inicio: 'fecha_inicio',
    fecha_fin: 'fecha_fin',
    ubicacion: 'ubicacion',
    hospitalId: 'hospitalId'
  };

  export type CampaniaScalarFieldEnum = (typeof CampaniaScalarFieldEnum)[keyof typeof CampaniaScalarFieldEnum]


  export const HospitalScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    direccion: 'direccion',
    numero: 'numero',
    telefono: 'telefono',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type HospitalScalarFieldEnum = (typeof HospitalScalarFieldEnum)[keyof typeof HospitalScalarFieldEnum]


  export const DonacionScalarFieldEnum: {
    id: 'id',
    fecha_donacion: 'fecha_donacion',
    tipo_donacion: 'tipo_donacion',
    estado: 'estado',
    DonanteId: 'DonanteId',
    campaniaId: 'campaniaId',
    hospitalId: 'hospitalId'
  };

  export type DonacionScalarFieldEnum = (typeof DonacionScalarFieldEnum)[keyof typeof DonacionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'GrupoSanguineo'
   */
  export type EnumGrupoSanguineoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GrupoSanguineo'>
    


  /**
   * Reference to a field of type 'GrupoSanguineo[]'
   */
  export type ListEnumGrupoSanguineoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GrupoSanguineo[]'>
    


  /**
   * Reference to a field of type 'FatorRH'
   */
  export type EnumFatorRHFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FatorRH'>
    


  /**
   * Reference to a field of type 'FatorRH[]'
   */
  export type ListEnumFatorRHFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FatorRH[]'>
    


  /**
   * Reference to a field of type 'Sexo'
   */
  export type EnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo'>
    


  /**
   * Reference to a field of type 'Sexo[]'
   */
  export type ListEnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo[]'>
    


  /**
   * Reference to a field of type 'EstadoDonante'
   */
  export type EnumEstadoDonanteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoDonante'>
    


  /**
   * Reference to a field of type 'EstadoDonante[]'
   */
  export type ListEnumEstadoDonanteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoDonante[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'TipoDonacion'
   */
  export type EnumTipoDonacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoDonacion'>
    


  /**
   * Reference to a field of type 'TipoDonacion[]'
   */
  export type ListEnumTipoDonacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoDonacion[]'>
    


  /**
   * Reference to a field of type 'EstadoDonacion'
   */
  export type EnumEstadoDonacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoDonacion'>
    


  /**
   * Reference to a field of type 'EstadoDonacion[]'
   */
  export type ListEnumEstadoDonacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoDonacion[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type DonanteWhereInput = {
    AND?: DonanteWhereInput | DonanteWhereInput[]
    OR?: DonanteWhereInput[]
    NOT?: DonanteWhereInput | DonanteWhereInput[]
    id?: IntFilter<"Donante"> | number
    dni?: StringFilter<"Donante"> | string
    nombre?: StringFilter<"Donante"> | string
    apellido?: StringFilter<"Donante"> | string
    email?: StringFilter<"Donante"> | string
    password?: StringFilter<"Donante"> | string
    createdAt?: DateTimeFilter<"Donante"> | Date | string
    isActive?: BoolFilter<"Donante"> | boolean
    grupo_sanguineo?: EnumGrupoSanguineoFilter<"Donante"> | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHFilter<"Donante"> | $Enums.FatorRH
    fecha_nacimiento?: DateTimeFilter<"Donante"> | Date | string
    sexo?: EnumSexoFilter<"Donante"> | $Enums.Sexo
    fecha_ultima_donacion?: DateTimeNullableFilter<"Donante"> | Date | string | null
    estado?: EnumEstadoDonanteFilter<"Donante"> | $Enums.EstadoDonante
    donaciones?: DonacionListRelationFilter
  }

  export type DonanteOrderByWithRelationInput = {
    id?: SortOrder
    dni?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    grupo_sanguineo?: SortOrder
    factor_rh?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    fecha_ultima_donacion?: SortOrderInput | SortOrder
    estado?: SortOrder
    donaciones?: DonacionOrderByRelationAggregateInput
  }

  export type DonanteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    dni?: string
    email?: string
    AND?: DonanteWhereInput | DonanteWhereInput[]
    OR?: DonanteWhereInput[]
    NOT?: DonanteWhereInput | DonanteWhereInput[]
    nombre?: StringFilter<"Donante"> | string
    apellido?: StringFilter<"Donante"> | string
    password?: StringFilter<"Donante"> | string
    createdAt?: DateTimeFilter<"Donante"> | Date | string
    isActive?: BoolFilter<"Donante"> | boolean
    grupo_sanguineo?: EnumGrupoSanguineoFilter<"Donante"> | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHFilter<"Donante"> | $Enums.FatorRH
    fecha_nacimiento?: DateTimeFilter<"Donante"> | Date | string
    sexo?: EnumSexoFilter<"Donante"> | $Enums.Sexo
    fecha_ultima_donacion?: DateTimeNullableFilter<"Donante"> | Date | string | null
    estado?: EnumEstadoDonanteFilter<"Donante"> | $Enums.EstadoDonante
    donaciones?: DonacionListRelationFilter
  }, "id" | "dni" | "email">

  export type DonanteOrderByWithAggregationInput = {
    id?: SortOrder
    dni?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    grupo_sanguineo?: SortOrder
    factor_rh?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    fecha_ultima_donacion?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: DonanteCountOrderByAggregateInput
    _avg?: DonanteAvgOrderByAggregateInput
    _max?: DonanteMaxOrderByAggregateInput
    _min?: DonanteMinOrderByAggregateInput
    _sum?: DonanteSumOrderByAggregateInput
  }

  export type DonanteScalarWhereWithAggregatesInput = {
    AND?: DonanteScalarWhereWithAggregatesInput | DonanteScalarWhereWithAggregatesInput[]
    OR?: DonanteScalarWhereWithAggregatesInput[]
    NOT?: DonanteScalarWhereWithAggregatesInput | DonanteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Donante"> | number
    dni?: StringWithAggregatesFilter<"Donante"> | string
    nombre?: StringWithAggregatesFilter<"Donante"> | string
    apellido?: StringWithAggregatesFilter<"Donante"> | string
    email?: StringWithAggregatesFilter<"Donante"> | string
    password?: StringWithAggregatesFilter<"Donante"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Donante"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Donante"> | boolean
    grupo_sanguineo?: EnumGrupoSanguineoWithAggregatesFilter<"Donante"> | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHWithAggregatesFilter<"Donante"> | $Enums.FatorRH
    fecha_nacimiento?: DateTimeWithAggregatesFilter<"Donante"> | Date | string
    sexo?: EnumSexoWithAggregatesFilter<"Donante"> | $Enums.Sexo
    fecha_ultima_donacion?: DateTimeNullableWithAggregatesFilter<"Donante"> | Date | string | null
    estado?: EnumEstadoDonanteWithAggregatesFilter<"Donante"> | $Enums.EstadoDonante
  }

  export type CampaniaWhereInput = {
    AND?: CampaniaWhereInput | CampaniaWhereInput[]
    OR?: CampaniaWhereInput[]
    NOT?: CampaniaWhereInput | CampaniaWhereInput[]
    id?: IntFilter<"Campania"> | number
    nombre?: StringFilter<"Campania"> | string
    descripcion?: StringNullableFilter<"Campania"> | string | null
    fecha_inicio?: DateTimeFilter<"Campania"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"Campania"> | Date | string | null
    ubicacion?: StringFilter<"Campania"> | string
    hospitalId?: IntFilter<"Campania"> | number
    hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    donaciones?: DonacionListRelationFilter
  }

  export type CampaniaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    ubicacion?: SortOrder
    hospitalId?: SortOrder
    hospital?: HospitalOrderByWithRelationInput
    donaciones?: DonacionOrderByRelationAggregateInput
  }

  export type CampaniaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CampaniaWhereInput | CampaniaWhereInput[]
    OR?: CampaniaWhereInput[]
    NOT?: CampaniaWhereInput | CampaniaWhereInput[]
    nombre?: StringFilter<"Campania"> | string
    descripcion?: StringNullableFilter<"Campania"> | string | null
    fecha_inicio?: DateTimeFilter<"Campania"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"Campania"> | Date | string | null
    ubicacion?: StringFilter<"Campania"> | string
    hospitalId?: IntFilter<"Campania"> | number
    hospital?: XOR<HospitalScalarRelationFilter, HospitalWhereInput>
    donaciones?: DonacionListRelationFilter
  }, "id">

  export type CampaniaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrderInput | SortOrder
    ubicacion?: SortOrder
    hospitalId?: SortOrder
    _count?: CampaniaCountOrderByAggregateInput
    _avg?: CampaniaAvgOrderByAggregateInput
    _max?: CampaniaMaxOrderByAggregateInput
    _min?: CampaniaMinOrderByAggregateInput
    _sum?: CampaniaSumOrderByAggregateInput
  }

  export type CampaniaScalarWhereWithAggregatesInput = {
    AND?: CampaniaScalarWhereWithAggregatesInput | CampaniaScalarWhereWithAggregatesInput[]
    OR?: CampaniaScalarWhereWithAggregatesInput[]
    NOT?: CampaniaScalarWhereWithAggregatesInput | CampaniaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Campania"> | number
    nombre?: StringWithAggregatesFilter<"Campania"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Campania"> | string | null
    fecha_inicio?: DateTimeWithAggregatesFilter<"Campania"> | Date | string
    fecha_fin?: DateTimeNullableWithAggregatesFilter<"Campania"> | Date | string | null
    ubicacion?: StringWithAggregatesFilter<"Campania"> | string
    hospitalId?: IntWithAggregatesFilter<"Campania"> | number
  }

  export type HospitalWhereInput = {
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    id?: IntFilter<"Hospital"> | number
    nombre?: StringFilter<"Hospital"> | string
    direccion?: StringFilter<"Hospital"> | string
    numero?: IntFilter<"Hospital"> | number
    telefono?: BigIntFilter<"Hospital"> | bigint | number
    isActive?: BoolFilter<"Hospital"> | boolean
    createdAt?: DateTimeFilter<"Hospital"> | Date | string
    campanias?: CampaniaListRelationFilter
    donaciones?: DonacionListRelationFilter
  }

  export type HospitalOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    numero?: SortOrder
    telefono?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    campanias?: CampaniaOrderByRelationAggregateInput
    donaciones?: DonacionOrderByRelationAggregateInput
  }

  export type HospitalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HospitalWhereInput | HospitalWhereInput[]
    OR?: HospitalWhereInput[]
    NOT?: HospitalWhereInput | HospitalWhereInput[]
    nombre?: StringFilter<"Hospital"> | string
    direccion?: StringFilter<"Hospital"> | string
    numero?: IntFilter<"Hospital"> | number
    telefono?: BigIntFilter<"Hospital"> | bigint | number
    isActive?: BoolFilter<"Hospital"> | boolean
    createdAt?: DateTimeFilter<"Hospital"> | Date | string
    campanias?: CampaniaListRelationFilter
    donaciones?: DonacionListRelationFilter
  }, "id">

  export type HospitalOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    numero?: SortOrder
    telefono?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: HospitalCountOrderByAggregateInput
    _avg?: HospitalAvgOrderByAggregateInput
    _max?: HospitalMaxOrderByAggregateInput
    _min?: HospitalMinOrderByAggregateInput
    _sum?: HospitalSumOrderByAggregateInput
  }

  export type HospitalScalarWhereWithAggregatesInput = {
    AND?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    OR?: HospitalScalarWhereWithAggregatesInput[]
    NOT?: HospitalScalarWhereWithAggregatesInput | HospitalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hospital"> | number
    nombre?: StringWithAggregatesFilter<"Hospital"> | string
    direccion?: StringWithAggregatesFilter<"Hospital"> | string
    numero?: IntWithAggregatesFilter<"Hospital"> | number
    telefono?: BigIntWithAggregatesFilter<"Hospital"> | bigint | number
    isActive?: BoolWithAggregatesFilter<"Hospital"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Hospital"> | Date | string
  }

  export type DonacionWhereInput = {
    AND?: DonacionWhereInput | DonacionWhereInput[]
    OR?: DonacionWhereInput[]
    NOT?: DonacionWhereInput | DonacionWhereInput[]
    id?: IntFilter<"Donacion"> | number
    fecha_donacion?: DateTimeFilter<"Donacion"> | Date | string
    tipo_donacion?: EnumTipoDonacionFilter<"Donacion"> | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFilter<"Donacion"> | $Enums.EstadoDonacion
    DonanteId?: IntFilter<"Donacion"> | number
    campaniaId?: IntNullableFilter<"Donacion"> | number | null
    hospitalId?: IntNullableFilter<"Donacion"> | number | null
    donante?: XOR<DonanteScalarRelationFilter, DonanteWhereInput>
    campania?: XOR<CampaniaNullableScalarRelationFilter, CampaniaWhereInput> | null
    hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null
  }

  export type DonacionOrderByWithRelationInput = {
    id?: SortOrder
    fecha_donacion?: SortOrder
    tipo_donacion?: SortOrder
    estado?: SortOrder
    DonanteId?: SortOrder
    campaniaId?: SortOrderInput | SortOrder
    hospitalId?: SortOrderInput | SortOrder
    donante?: DonanteOrderByWithRelationInput
    campania?: CampaniaOrderByWithRelationInput
    hospital?: HospitalOrderByWithRelationInput
  }

  export type DonacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DonacionWhereInput | DonacionWhereInput[]
    OR?: DonacionWhereInput[]
    NOT?: DonacionWhereInput | DonacionWhereInput[]
    fecha_donacion?: DateTimeFilter<"Donacion"> | Date | string
    tipo_donacion?: EnumTipoDonacionFilter<"Donacion"> | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFilter<"Donacion"> | $Enums.EstadoDonacion
    DonanteId?: IntFilter<"Donacion"> | number
    campaniaId?: IntNullableFilter<"Donacion"> | number | null
    hospitalId?: IntNullableFilter<"Donacion"> | number | null
    donante?: XOR<DonanteScalarRelationFilter, DonanteWhereInput>
    campania?: XOR<CampaniaNullableScalarRelationFilter, CampaniaWhereInput> | null
    hospital?: XOR<HospitalNullableScalarRelationFilter, HospitalWhereInput> | null
  }, "id">

  export type DonacionOrderByWithAggregationInput = {
    id?: SortOrder
    fecha_donacion?: SortOrder
    tipo_donacion?: SortOrder
    estado?: SortOrder
    DonanteId?: SortOrder
    campaniaId?: SortOrderInput | SortOrder
    hospitalId?: SortOrderInput | SortOrder
    _count?: DonacionCountOrderByAggregateInput
    _avg?: DonacionAvgOrderByAggregateInput
    _max?: DonacionMaxOrderByAggregateInput
    _min?: DonacionMinOrderByAggregateInput
    _sum?: DonacionSumOrderByAggregateInput
  }

  export type DonacionScalarWhereWithAggregatesInput = {
    AND?: DonacionScalarWhereWithAggregatesInput | DonacionScalarWhereWithAggregatesInput[]
    OR?: DonacionScalarWhereWithAggregatesInput[]
    NOT?: DonacionScalarWhereWithAggregatesInput | DonacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Donacion"> | number
    fecha_donacion?: DateTimeWithAggregatesFilter<"Donacion"> | Date | string
    tipo_donacion?: EnumTipoDonacionWithAggregatesFilter<"Donacion"> | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionWithAggregatesFilter<"Donacion"> | $Enums.EstadoDonacion
    DonanteId?: IntWithAggregatesFilter<"Donacion"> | number
    campaniaId?: IntNullableWithAggregatesFilter<"Donacion"> | number | null
    hospitalId?: IntNullableWithAggregatesFilter<"Donacion"> | number | null
  }

  export type DonanteCreateInput = {
    dni: string
    nombre: string
    apellido: string
    email: string
    password: string
    createdAt?: Date | string
    isActive?: boolean
    grupo_sanguineo: $Enums.GrupoSanguineo
    factor_rh: $Enums.FatorRH
    fecha_nacimiento: Date | string
    sexo: $Enums.Sexo
    fecha_ultima_donacion?: Date | string | null
    estado?: $Enums.EstadoDonante
    donaciones?: DonacionCreateNestedManyWithoutDonanteInput
  }

  export type DonanteUncheckedCreateInput = {
    id?: number
    dni: string
    nombre: string
    apellido: string
    email: string
    password: string
    createdAt?: Date | string
    isActive?: boolean
    grupo_sanguineo: $Enums.GrupoSanguineo
    factor_rh: $Enums.FatorRH
    fecha_nacimiento: Date | string
    sexo: $Enums.Sexo
    fecha_ultima_donacion?: Date | string | null
    estado?: $Enums.EstadoDonante
    donaciones?: DonacionUncheckedCreateNestedManyWithoutDonanteInput
  }

  export type DonanteUpdateInput = {
    dni?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    grupo_sanguineo?: EnumGrupoSanguineoFieldUpdateOperationsInput | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHFieldUpdateOperationsInput | $Enums.FatorRH
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    fecha_ultima_donacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoDonanteFieldUpdateOperationsInput | $Enums.EstadoDonante
    donaciones?: DonacionUpdateManyWithoutDonanteNestedInput
  }

  export type DonanteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    grupo_sanguineo?: EnumGrupoSanguineoFieldUpdateOperationsInput | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHFieldUpdateOperationsInput | $Enums.FatorRH
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    fecha_ultima_donacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoDonanteFieldUpdateOperationsInput | $Enums.EstadoDonante
    donaciones?: DonacionUncheckedUpdateManyWithoutDonanteNestedInput
  }

  export type DonanteCreateManyInput = {
    id?: number
    dni: string
    nombre: string
    apellido: string
    email: string
    password: string
    createdAt?: Date | string
    isActive?: boolean
    grupo_sanguineo: $Enums.GrupoSanguineo
    factor_rh: $Enums.FatorRH
    fecha_nacimiento: Date | string
    sexo: $Enums.Sexo
    fecha_ultima_donacion?: Date | string | null
    estado?: $Enums.EstadoDonante
  }

  export type DonanteUpdateManyMutationInput = {
    dni?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    grupo_sanguineo?: EnumGrupoSanguineoFieldUpdateOperationsInput | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHFieldUpdateOperationsInput | $Enums.FatorRH
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    fecha_ultima_donacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoDonanteFieldUpdateOperationsInput | $Enums.EstadoDonante
  }

  export type DonanteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    grupo_sanguineo?: EnumGrupoSanguineoFieldUpdateOperationsInput | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHFieldUpdateOperationsInput | $Enums.FatorRH
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    fecha_ultima_donacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoDonanteFieldUpdateOperationsInput | $Enums.EstadoDonante
  }

  export type CampaniaCreateInput = {
    nombre: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    ubicacion: string
    hospital: HospitalCreateNestedOneWithoutCampaniasInput
    donaciones?: DonacionCreateNestedManyWithoutCampaniaInput
  }

  export type CampaniaUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    ubicacion: string
    hospitalId: number
    donaciones?: DonacionUncheckedCreateNestedManyWithoutCampaniaInput
  }

  export type CampaniaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
    hospital?: HospitalUpdateOneRequiredWithoutCampaniasNestedInput
    donaciones?: DonacionUpdateManyWithoutCampaniaNestedInput
  }

  export type CampaniaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
    hospitalId?: IntFieldUpdateOperationsInput | number
    donaciones?: DonacionUncheckedUpdateManyWithoutCampaniaNestedInput
  }

  export type CampaniaCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    ubicacion: string
    hospitalId: number
  }

  export type CampaniaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
  }

  export type CampaniaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
    hospitalId?: IntFieldUpdateOperationsInput | number
  }

  export type HospitalCreateInput = {
    nombre: string
    direccion: string
    numero: number
    telefono: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    campanias?: CampaniaCreateNestedManyWithoutHospitalInput
    donaciones?: DonacionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateInput = {
    id?: number
    nombre: string
    direccion: string
    numero: number
    telefono: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    campanias?: CampaniaUncheckedCreateNestedManyWithoutHospitalInput
    donaciones?: DonacionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    telefono?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campanias?: CampaniaUpdateManyWithoutHospitalNestedInput
    donaciones?: DonacionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    telefono?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campanias?: CampaniaUncheckedUpdateManyWithoutHospitalNestedInput
    donaciones?: DonacionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalCreateManyInput = {
    id?: number
    nombre: string
    direccion: string
    numero: number
    telefono: bigint | number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type HospitalUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    telefono?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    telefono?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonacionCreateInput = {
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    donante: DonanteCreateNestedOneWithoutDonacionesInput
    campania?: CampaniaCreateNestedOneWithoutDonacionesInput
    hospital?: HospitalCreateNestedOneWithoutDonacionesInput
  }

  export type DonacionUncheckedCreateInput = {
    id?: number
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    DonanteId: number
    campaniaId?: number | null
    hospitalId?: number | null
  }

  export type DonacionUpdateInput = {
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    donante?: DonanteUpdateOneRequiredWithoutDonacionesNestedInput
    campania?: CampaniaUpdateOneWithoutDonacionesNestedInput
    hospital?: HospitalUpdateOneWithoutDonacionesNestedInput
  }

  export type DonacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    DonanteId?: IntFieldUpdateOperationsInput | number
    campaniaId?: NullableIntFieldUpdateOperationsInput | number | null
    hospitalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DonacionCreateManyInput = {
    id?: number
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    DonanteId: number
    campaniaId?: number | null
    hospitalId?: number | null
  }

  export type DonacionUpdateManyMutationInput = {
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
  }

  export type DonacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    DonanteId?: IntFieldUpdateOperationsInput | number
    campaniaId?: NullableIntFieldUpdateOperationsInput | number | null
    hospitalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumGrupoSanguineoFilter<$PrismaModel = never> = {
    equals?: $Enums.GrupoSanguineo | EnumGrupoSanguineoFieldRefInput<$PrismaModel>
    in?: $Enums.GrupoSanguineo[] | ListEnumGrupoSanguineoFieldRefInput<$PrismaModel>
    notIn?: $Enums.GrupoSanguineo[] | ListEnumGrupoSanguineoFieldRefInput<$PrismaModel>
    not?: NestedEnumGrupoSanguineoFilter<$PrismaModel> | $Enums.GrupoSanguineo
  }

  export type EnumFatorRHFilter<$PrismaModel = never> = {
    equals?: $Enums.FatorRH | EnumFatorRHFieldRefInput<$PrismaModel>
    in?: $Enums.FatorRH[] | ListEnumFatorRHFieldRefInput<$PrismaModel>
    notIn?: $Enums.FatorRH[] | ListEnumFatorRHFieldRefInput<$PrismaModel>
    not?: NestedEnumFatorRHFilter<$PrismaModel> | $Enums.FatorRH
  }

  export type EnumSexoFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoFilter<$PrismaModel> | $Enums.Sexo
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumEstadoDonanteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDonante | EnumEstadoDonanteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDonante[] | ListEnumEstadoDonanteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDonante[] | ListEnumEstadoDonanteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDonanteFilter<$PrismaModel> | $Enums.EstadoDonante
  }

  export type DonacionListRelationFilter = {
    every?: DonacionWhereInput
    some?: DonacionWhereInput
    none?: DonacionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DonacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonanteCountOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    grupo_sanguineo?: SortOrder
    factor_rh?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    fecha_ultima_donacion?: SortOrder
    estado?: SortOrder
  }

  export type DonanteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DonanteMaxOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    grupo_sanguineo?: SortOrder
    factor_rh?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    fecha_ultima_donacion?: SortOrder
    estado?: SortOrder
  }

  export type DonanteMinOrderByAggregateInput = {
    id?: SortOrder
    dni?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    grupo_sanguineo?: SortOrder
    factor_rh?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    fecha_ultima_donacion?: SortOrder
    estado?: SortOrder
  }

  export type DonanteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumGrupoSanguineoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GrupoSanguineo | EnumGrupoSanguineoFieldRefInput<$PrismaModel>
    in?: $Enums.GrupoSanguineo[] | ListEnumGrupoSanguineoFieldRefInput<$PrismaModel>
    notIn?: $Enums.GrupoSanguineo[] | ListEnumGrupoSanguineoFieldRefInput<$PrismaModel>
    not?: NestedEnumGrupoSanguineoWithAggregatesFilter<$PrismaModel> | $Enums.GrupoSanguineo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGrupoSanguineoFilter<$PrismaModel>
    _max?: NestedEnumGrupoSanguineoFilter<$PrismaModel>
  }

  export type EnumFatorRHWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FatorRH | EnumFatorRHFieldRefInput<$PrismaModel>
    in?: $Enums.FatorRH[] | ListEnumFatorRHFieldRefInput<$PrismaModel>
    notIn?: $Enums.FatorRH[] | ListEnumFatorRHFieldRefInput<$PrismaModel>
    not?: NestedEnumFatorRHWithAggregatesFilter<$PrismaModel> | $Enums.FatorRH
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFatorRHFilter<$PrismaModel>
    _max?: NestedEnumFatorRHFilter<$PrismaModel>
  }

  export type EnumSexoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoWithAggregatesFilter<$PrismaModel> | $Enums.Sexo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexoFilter<$PrismaModel>
    _max?: NestedEnumSexoFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumEstadoDonanteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDonante | EnumEstadoDonanteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDonante[] | ListEnumEstadoDonanteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDonante[] | ListEnumEstadoDonanteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDonanteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoDonante
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoDonanteFilter<$PrismaModel>
    _max?: NestedEnumEstadoDonanteFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type HospitalScalarRelationFilter = {
    is?: HospitalWhereInput
    isNot?: HospitalWhereInput
  }

  export type CampaniaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    ubicacion?: SortOrder
    hospitalId?: SortOrder
  }

  export type CampaniaAvgOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
  }

  export type CampaniaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    ubicacion?: SortOrder
    hospitalId?: SortOrder
  }

  export type CampaniaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fecha_inicio?: SortOrder
    fecha_fin?: SortOrder
    ubicacion?: SortOrder
    hospitalId?: SortOrder
  }

  export type CampaniaSumOrderByAggregateInput = {
    id?: SortOrder
    hospitalId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type CampaniaListRelationFilter = {
    every?: CampaniaWhereInput
    some?: CampaniaWhereInput
    none?: CampaniaWhereInput
  }

  export type CampaniaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HospitalCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    numero?: SortOrder
    telefono?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type HospitalAvgOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    telefono?: SortOrder
  }

  export type HospitalMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    numero?: SortOrder
    telefono?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type HospitalMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    numero?: SortOrder
    telefono?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type HospitalSumOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    telefono?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumTipoDonacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDonacion | EnumTipoDonacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDonacion[] | ListEnumTipoDonacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDonacion[] | ListEnumTipoDonacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDonacionFilter<$PrismaModel> | $Enums.TipoDonacion
  }

  export type EnumEstadoDonacionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDonacion | EnumEstadoDonacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDonacion[] | ListEnumEstadoDonacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDonacion[] | ListEnumEstadoDonacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDonacionFilter<$PrismaModel> | $Enums.EstadoDonacion
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DonanteScalarRelationFilter = {
    is?: DonanteWhereInput
    isNot?: DonanteWhereInput
  }

  export type CampaniaNullableScalarRelationFilter = {
    is?: CampaniaWhereInput | null
    isNot?: CampaniaWhereInput | null
  }

  export type HospitalNullableScalarRelationFilter = {
    is?: HospitalWhereInput | null
    isNot?: HospitalWhereInput | null
  }

  export type DonacionCountOrderByAggregateInput = {
    id?: SortOrder
    fecha_donacion?: SortOrder
    tipo_donacion?: SortOrder
    estado?: SortOrder
    DonanteId?: SortOrder
    campaniaId?: SortOrder
    hospitalId?: SortOrder
  }

  export type DonacionAvgOrderByAggregateInput = {
    id?: SortOrder
    DonanteId?: SortOrder
    campaniaId?: SortOrder
    hospitalId?: SortOrder
  }

  export type DonacionMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha_donacion?: SortOrder
    tipo_donacion?: SortOrder
    estado?: SortOrder
    DonanteId?: SortOrder
    campaniaId?: SortOrder
    hospitalId?: SortOrder
  }

  export type DonacionMinOrderByAggregateInput = {
    id?: SortOrder
    fecha_donacion?: SortOrder
    tipo_donacion?: SortOrder
    estado?: SortOrder
    DonanteId?: SortOrder
    campaniaId?: SortOrder
    hospitalId?: SortOrder
  }

  export type DonacionSumOrderByAggregateInput = {
    id?: SortOrder
    DonanteId?: SortOrder
    campaniaId?: SortOrder
    hospitalId?: SortOrder
  }

  export type EnumTipoDonacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDonacion | EnumTipoDonacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDonacion[] | ListEnumTipoDonacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDonacion[] | ListEnumTipoDonacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDonacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoDonacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoDonacionFilter<$PrismaModel>
    _max?: NestedEnumTipoDonacionFilter<$PrismaModel>
  }

  export type EnumEstadoDonacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDonacion | EnumEstadoDonacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDonacion[] | ListEnumEstadoDonacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDonacion[] | ListEnumEstadoDonacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDonacionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoDonacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoDonacionFilter<$PrismaModel>
    _max?: NestedEnumEstadoDonacionFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DonacionCreateNestedManyWithoutDonanteInput = {
    create?: XOR<DonacionCreateWithoutDonanteInput, DonacionUncheckedCreateWithoutDonanteInput> | DonacionCreateWithoutDonanteInput[] | DonacionUncheckedCreateWithoutDonanteInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutDonanteInput | DonacionCreateOrConnectWithoutDonanteInput[]
    createMany?: DonacionCreateManyDonanteInputEnvelope
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
  }

  export type DonacionUncheckedCreateNestedManyWithoutDonanteInput = {
    create?: XOR<DonacionCreateWithoutDonanteInput, DonacionUncheckedCreateWithoutDonanteInput> | DonacionCreateWithoutDonanteInput[] | DonacionUncheckedCreateWithoutDonanteInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutDonanteInput | DonacionCreateOrConnectWithoutDonanteInput[]
    createMany?: DonacionCreateManyDonanteInputEnvelope
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumGrupoSanguineoFieldUpdateOperationsInput = {
    set?: $Enums.GrupoSanguineo
  }

  export type EnumFatorRHFieldUpdateOperationsInput = {
    set?: $Enums.FatorRH
  }

  export type EnumSexoFieldUpdateOperationsInput = {
    set?: $Enums.Sexo
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumEstadoDonanteFieldUpdateOperationsInput = {
    set?: $Enums.EstadoDonante
  }

  export type DonacionUpdateManyWithoutDonanteNestedInput = {
    create?: XOR<DonacionCreateWithoutDonanteInput, DonacionUncheckedCreateWithoutDonanteInput> | DonacionCreateWithoutDonanteInput[] | DonacionUncheckedCreateWithoutDonanteInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutDonanteInput | DonacionCreateOrConnectWithoutDonanteInput[]
    upsert?: DonacionUpsertWithWhereUniqueWithoutDonanteInput | DonacionUpsertWithWhereUniqueWithoutDonanteInput[]
    createMany?: DonacionCreateManyDonanteInputEnvelope
    set?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    disconnect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    delete?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    update?: DonacionUpdateWithWhereUniqueWithoutDonanteInput | DonacionUpdateWithWhereUniqueWithoutDonanteInput[]
    updateMany?: DonacionUpdateManyWithWhereWithoutDonanteInput | DonacionUpdateManyWithWhereWithoutDonanteInput[]
    deleteMany?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DonacionUncheckedUpdateManyWithoutDonanteNestedInput = {
    create?: XOR<DonacionCreateWithoutDonanteInput, DonacionUncheckedCreateWithoutDonanteInput> | DonacionCreateWithoutDonanteInput[] | DonacionUncheckedCreateWithoutDonanteInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutDonanteInput | DonacionCreateOrConnectWithoutDonanteInput[]
    upsert?: DonacionUpsertWithWhereUniqueWithoutDonanteInput | DonacionUpsertWithWhereUniqueWithoutDonanteInput[]
    createMany?: DonacionCreateManyDonanteInputEnvelope
    set?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    disconnect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    delete?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    update?: DonacionUpdateWithWhereUniqueWithoutDonanteInput | DonacionUpdateWithWhereUniqueWithoutDonanteInput[]
    updateMany?: DonacionUpdateManyWithWhereWithoutDonanteInput | DonacionUpdateManyWithWhereWithoutDonanteInput[]
    deleteMany?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
  }

  export type HospitalCreateNestedOneWithoutCampaniasInput = {
    create?: XOR<HospitalCreateWithoutCampaniasInput, HospitalUncheckedCreateWithoutCampaniasInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutCampaniasInput
    connect?: HospitalWhereUniqueInput
  }

  export type DonacionCreateNestedManyWithoutCampaniaInput = {
    create?: XOR<DonacionCreateWithoutCampaniaInput, DonacionUncheckedCreateWithoutCampaniaInput> | DonacionCreateWithoutCampaniaInput[] | DonacionUncheckedCreateWithoutCampaniaInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutCampaniaInput | DonacionCreateOrConnectWithoutCampaniaInput[]
    createMany?: DonacionCreateManyCampaniaInputEnvelope
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
  }

  export type DonacionUncheckedCreateNestedManyWithoutCampaniaInput = {
    create?: XOR<DonacionCreateWithoutCampaniaInput, DonacionUncheckedCreateWithoutCampaniaInput> | DonacionCreateWithoutCampaniaInput[] | DonacionUncheckedCreateWithoutCampaniaInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutCampaniaInput | DonacionCreateOrConnectWithoutCampaniaInput[]
    createMany?: DonacionCreateManyCampaniaInputEnvelope
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type HospitalUpdateOneRequiredWithoutCampaniasNestedInput = {
    create?: XOR<HospitalCreateWithoutCampaniasInput, HospitalUncheckedCreateWithoutCampaniasInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutCampaniasInput
    upsert?: HospitalUpsertWithoutCampaniasInput
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutCampaniasInput, HospitalUpdateWithoutCampaniasInput>, HospitalUncheckedUpdateWithoutCampaniasInput>
  }

  export type DonacionUpdateManyWithoutCampaniaNestedInput = {
    create?: XOR<DonacionCreateWithoutCampaniaInput, DonacionUncheckedCreateWithoutCampaniaInput> | DonacionCreateWithoutCampaniaInput[] | DonacionUncheckedCreateWithoutCampaniaInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutCampaniaInput | DonacionCreateOrConnectWithoutCampaniaInput[]
    upsert?: DonacionUpsertWithWhereUniqueWithoutCampaniaInput | DonacionUpsertWithWhereUniqueWithoutCampaniaInput[]
    createMany?: DonacionCreateManyCampaniaInputEnvelope
    set?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    disconnect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    delete?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    update?: DonacionUpdateWithWhereUniqueWithoutCampaniaInput | DonacionUpdateWithWhereUniqueWithoutCampaniaInput[]
    updateMany?: DonacionUpdateManyWithWhereWithoutCampaniaInput | DonacionUpdateManyWithWhereWithoutCampaniaInput[]
    deleteMany?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
  }

  export type DonacionUncheckedUpdateManyWithoutCampaniaNestedInput = {
    create?: XOR<DonacionCreateWithoutCampaniaInput, DonacionUncheckedCreateWithoutCampaniaInput> | DonacionCreateWithoutCampaniaInput[] | DonacionUncheckedCreateWithoutCampaniaInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutCampaniaInput | DonacionCreateOrConnectWithoutCampaniaInput[]
    upsert?: DonacionUpsertWithWhereUniqueWithoutCampaniaInput | DonacionUpsertWithWhereUniqueWithoutCampaniaInput[]
    createMany?: DonacionCreateManyCampaniaInputEnvelope
    set?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    disconnect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    delete?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    update?: DonacionUpdateWithWhereUniqueWithoutCampaniaInput | DonacionUpdateWithWhereUniqueWithoutCampaniaInput[]
    updateMany?: DonacionUpdateManyWithWhereWithoutCampaniaInput | DonacionUpdateManyWithWhereWithoutCampaniaInput[]
    deleteMany?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
  }

  export type CampaniaCreateNestedManyWithoutHospitalInput = {
    create?: XOR<CampaniaCreateWithoutHospitalInput, CampaniaUncheckedCreateWithoutHospitalInput> | CampaniaCreateWithoutHospitalInput[] | CampaniaUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: CampaniaCreateOrConnectWithoutHospitalInput | CampaniaCreateOrConnectWithoutHospitalInput[]
    createMany?: CampaniaCreateManyHospitalInputEnvelope
    connect?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
  }

  export type DonacionCreateNestedManyWithoutHospitalInput = {
    create?: XOR<DonacionCreateWithoutHospitalInput, DonacionUncheckedCreateWithoutHospitalInput> | DonacionCreateWithoutHospitalInput[] | DonacionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutHospitalInput | DonacionCreateOrConnectWithoutHospitalInput[]
    createMany?: DonacionCreateManyHospitalInputEnvelope
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
  }

  export type CampaniaUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<CampaniaCreateWithoutHospitalInput, CampaniaUncheckedCreateWithoutHospitalInput> | CampaniaCreateWithoutHospitalInput[] | CampaniaUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: CampaniaCreateOrConnectWithoutHospitalInput | CampaniaCreateOrConnectWithoutHospitalInput[]
    createMany?: CampaniaCreateManyHospitalInputEnvelope
    connect?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
  }

  export type DonacionUncheckedCreateNestedManyWithoutHospitalInput = {
    create?: XOR<DonacionCreateWithoutHospitalInput, DonacionUncheckedCreateWithoutHospitalInput> | DonacionCreateWithoutHospitalInput[] | DonacionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutHospitalInput | DonacionCreateOrConnectWithoutHospitalInput[]
    createMany?: DonacionCreateManyHospitalInputEnvelope
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type CampaniaUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<CampaniaCreateWithoutHospitalInput, CampaniaUncheckedCreateWithoutHospitalInput> | CampaniaCreateWithoutHospitalInput[] | CampaniaUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: CampaniaCreateOrConnectWithoutHospitalInput | CampaniaCreateOrConnectWithoutHospitalInput[]
    upsert?: CampaniaUpsertWithWhereUniqueWithoutHospitalInput | CampaniaUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: CampaniaCreateManyHospitalInputEnvelope
    set?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
    disconnect?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
    delete?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
    connect?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
    update?: CampaniaUpdateWithWhereUniqueWithoutHospitalInput | CampaniaUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: CampaniaUpdateManyWithWhereWithoutHospitalInput | CampaniaUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: CampaniaScalarWhereInput | CampaniaScalarWhereInput[]
  }

  export type DonacionUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<DonacionCreateWithoutHospitalInput, DonacionUncheckedCreateWithoutHospitalInput> | DonacionCreateWithoutHospitalInput[] | DonacionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutHospitalInput | DonacionCreateOrConnectWithoutHospitalInput[]
    upsert?: DonacionUpsertWithWhereUniqueWithoutHospitalInput | DonacionUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: DonacionCreateManyHospitalInputEnvelope
    set?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    disconnect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    delete?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    update?: DonacionUpdateWithWhereUniqueWithoutHospitalInput | DonacionUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: DonacionUpdateManyWithWhereWithoutHospitalInput | DonacionUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
  }

  export type CampaniaUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<CampaniaCreateWithoutHospitalInput, CampaniaUncheckedCreateWithoutHospitalInput> | CampaniaCreateWithoutHospitalInput[] | CampaniaUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: CampaniaCreateOrConnectWithoutHospitalInput | CampaniaCreateOrConnectWithoutHospitalInput[]
    upsert?: CampaniaUpsertWithWhereUniqueWithoutHospitalInput | CampaniaUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: CampaniaCreateManyHospitalInputEnvelope
    set?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
    disconnect?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
    delete?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
    connect?: CampaniaWhereUniqueInput | CampaniaWhereUniqueInput[]
    update?: CampaniaUpdateWithWhereUniqueWithoutHospitalInput | CampaniaUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: CampaniaUpdateManyWithWhereWithoutHospitalInput | CampaniaUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: CampaniaScalarWhereInput | CampaniaScalarWhereInput[]
  }

  export type DonacionUncheckedUpdateManyWithoutHospitalNestedInput = {
    create?: XOR<DonacionCreateWithoutHospitalInput, DonacionUncheckedCreateWithoutHospitalInput> | DonacionCreateWithoutHospitalInput[] | DonacionUncheckedCreateWithoutHospitalInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutHospitalInput | DonacionCreateOrConnectWithoutHospitalInput[]
    upsert?: DonacionUpsertWithWhereUniqueWithoutHospitalInput | DonacionUpsertWithWhereUniqueWithoutHospitalInput[]
    createMany?: DonacionCreateManyHospitalInputEnvelope
    set?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    disconnect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    delete?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    update?: DonacionUpdateWithWhereUniqueWithoutHospitalInput | DonacionUpdateWithWhereUniqueWithoutHospitalInput[]
    updateMany?: DonacionUpdateManyWithWhereWithoutHospitalInput | DonacionUpdateManyWithWhereWithoutHospitalInput[]
    deleteMany?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
  }

  export type DonanteCreateNestedOneWithoutDonacionesInput = {
    create?: XOR<DonanteCreateWithoutDonacionesInput, DonanteUncheckedCreateWithoutDonacionesInput>
    connectOrCreate?: DonanteCreateOrConnectWithoutDonacionesInput
    connect?: DonanteWhereUniqueInput
  }

  export type CampaniaCreateNestedOneWithoutDonacionesInput = {
    create?: XOR<CampaniaCreateWithoutDonacionesInput, CampaniaUncheckedCreateWithoutDonacionesInput>
    connectOrCreate?: CampaniaCreateOrConnectWithoutDonacionesInput
    connect?: CampaniaWhereUniqueInput
  }

  export type HospitalCreateNestedOneWithoutDonacionesInput = {
    create?: XOR<HospitalCreateWithoutDonacionesInput, HospitalUncheckedCreateWithoutDonacionesInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutDonacionesInput
    connect?: HospitalWhereUniqueInput
  }

  export type EnumTipoDonacionFieldUpdateOperationsInput = {
    set?: $Enums.TipoDonacion
  }

  export type EnumEstadoDonacionFieldUpdateOperationsInput = {
    set?: $Enums.EstadoDonacion
  }

  export type DonanteUpdateOneRequiredWithoutDonacionesNestedInput = {
    create?: XOR<DonanteCreateWithoutDonacionesInput, DonanteUncheckedCreateWithoutDonacionesInput>
    connectOrCreate?: DonanteCreateOrConnectWithoutDonacionesInput
    upsert?: DonanteUpsertWithoutDonacionesInput
    connect?: DonanteWhereUniqueInput
    update?: XOR<XOR<DonanteUpdateToOneWithWhereWithoutDonacionesInput, DonanteUpdateWithoutDonacionesInput>, DonanteUncheckedUpdateWithoutDonacionesInput>
  }

  export type CampaniaUpdateOneWithoutDonacionesNestedInput = {
    create?: XOR<CampaniaCreateWithoutDonacionesInput, CampaniaUncheckedCreateWithoutDonacionesInput>
    connectOrCreate?: CampaniaCreateOrConnectWithoutDonacionesInput
    upsert?: CampaniaUpsertWithoutDonacionesInput
    disconnect?: CampaniaWhereInput | boolean
    delete?: CampaniaWhereInput | boolean
    connect?: CampaniaWhereUniqueInput
    update?: XOR<XOR<CampaniaUpdateToOneWithWhereWithoutDonacionesInput, CampaniaUpdateWithoutDonacionesInput>, CampaniaUncheckedUpdateWithoutDonacionesInput>
  }

  export type HospitalUpdateOneWithoutDonacionesNestedInput = {
    create?: XOR<HospitalCreateWithoutDonacionesInput, HospitalUncheckedCreateWithoutDonacionesInput>
    connectOrCreate?: HospitalCreateOrConnectWithoutDonacionesInput
    upsert?: HospitalUpsertWithoutDonacionesInput
    disconnect?: HospitalWhereInput | boolean
    delete?: HospitalWhereInput | boolean
    connect?: HospitalWhereUniqueInput
    update?: XOR<XOR<HospitalUpdateToOneWithWhereWithoutDonacionesInput, HospitalUpdateWithoutDonacionesInput>, HospitalUncheckedUpdateWithoutDonacionesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumGrupoSanguineoFilter<$PrismaModel = never> = {
    equals?: $Enums.GrupoSanguineo | EnumGrupoSanguineoFieldRefInput<$PrismaModel>
    in?: $Enums.GrupoSanguineo[] | ListEnumGrupoSanguineoFieldRefInput<$PrismaModel>
    notIn?: $Enums.GrupoSanguineo[] | ListEnumGrupoSanguineoFieldRefInput<$PrismaModel>
    not?: NestedEnumGrupoSanguineoFilter<$PrismaModel> | $Enums.GrupoSanguineo
  }

  export type NestedEnumFatorRHFilter<$PrismaModel = never> = {
    equals?: $Enums.FatorRH | EnumFatorRHFieldRefInput<$PrismaModel>
    in?: $Enums.FatorRH[] | ListEnumFatorRHFieldRefInput<$PrismaModel>
    notIn?: $Enums.FatorRH[] | ListEnumFatorRHFieldRefInput<$PrismaModel>
    not?: NestedEnumFatorRHFilter<$PrismaModel> | $Enums.FatorRH
  }

  export type NestedEnumSexoFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoFilter<$PrismaModel> | $Enums.Sexo
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumEstadoDonanteFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDonante | EnumEstadoDonanteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDonante[] | ListEnumEstadoDonanteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDonante[] | ListEnumEstadoDonanteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDonanteFilter<$PrismaModel> | $Enums.EstadoDonante
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumGrupoSanguineoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GrupoSanguineo | EnumGrupoSanguineoFieldRefInput<$PrismaModel>
    in?: $Enums.GrupoSanguineo[] | ListEnumGrupoSanguineoFieldRefInput<$PrismaModel>
    notIn?: $Enums.GrupoSanguineo[] | ListEnumGrupoSanguineoFieldRefInput<$PrismaModel>
    not?: NestedEnumGrupoSanguineoWithAggregatesFilter<$PrismaModel> | $Enums.GrupoSanguineo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGrupoSanguineoFilter<$PrismaModel>
    _max?: NestedEnumGrupoSanguineoFilter<$PrismaModel>
  }

  export type NestedEnumFatorRHWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FatorRH | EnumFatorRHFieldRefInput<$PrismaModel>
    in?: $Enums.FatorRH[] | ListEnumFatorRHFieldRefInput<$PrismaModel>
    notIn?: $Enums.FatorRH[] | ListEnumFatorRHFieldRefInput<$PrismaModel>
    not?: NestedEnumFatorRHWithAggregatesFilter<$PrismaModel> | $Enums.FatorRH
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFatorRHFilter<$PrismaModel>
    _max?: NestedEnumFatorRHFilter<$PrismaModel>
  }

  export type NestedEnumSexoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoWithAggregatesFilter<$PrismaModel> | $Enums.Sexo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexoFilter<$PrismaModel>
    _max?: NestedEnumSexoFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEstadoDonanteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDonante | EnumEstadoDonanteFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDonante[] | ListEnumEstadoDonanteFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDonante[] | ListEnumEstadoDonanteFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDonanteWithAggregatesFilter<$PrismaModel> | $Enums.EstadoDonante
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoDonanteFilter<$PrismaModel>
    _max?: NestedEnumEstadoDonanteFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumTipoDonacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDonacion | EnumTipoDonacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDonacion[] | ListEnumTipoDonacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDonacion[] | ListEnumTipoDonacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDonacionFilter<$PrismaModel> | $Enums.TipoDonacion
  }

  export type NestedEnumEstadoDonacionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDonacion | EnumEstadoDonacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDonacion[] | ListEnumEstadoDonacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDonacion[] | ListEnumEstadoDonacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDonacionFilter<$PrismaModel> | $Enums.EstadoDonacion
  }

  export type NestedEnumTipoDonacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDonacion | EnumTipoDonacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDonacion[] | ListEnumTipoDonacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDonacion[] | ListEnumTipoDonacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDonacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoDonacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoDonacionFilter<$PrismaModel>
    _max?: NestedEnumTipoDonacionFilter<$PrismaModel>
  }

  export type NestedEnumEstadoDonacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDonacion | EnumEstadoDonacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDonacion[] | ListEnumEstadoDonacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDonacion[] | ListEnumEstadoDonacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDonacionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoDonacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoDonacionFilter<$PrismaModel>
    _max?: NestedEnumEstadoDonacionFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DonacionCreateWithoutDonanteInput = {
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    campania?: CampaniaCreateNestedOneWithoutDonacionesInput
    hospital?: HospitalCreateNestedOneWithoutDonacionesInput
  }

  export type DonacionUncheckedCreateWithoutDonanteInput = {
    id?: number
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    campaniaId?: number | null
    hospitalId?: number | null
  }

  export type DonacionCreateOrConnectWithoutDonanteInput = {
    where: DonacionWhereUniqueInput
    create: XOR<DonacionCreateWithoutDonanteInput, DonacionUncheckedCreateWithoutDonanteInput>
  }

  export type DonacionCreateManyDonanteInputEnvelope = {
    data: DonacionCreateManyDonanteInput | DonacionCreateManyDonanteInput[]
    skipDuplicates?: boolean
  }

  export type DonacionUpsertWithWhereUniqueWithoutDonanteInput = {
    where: DonacionWhereUniqueInput
    update: XOR<DonacionUpdateWithoutDonanteInput, DonacionUncheckedUpdateWithoutDonanteInput>
    create: XOR<DonacionCreateWithoutDonanteInput, DonacionUncheckedCreateWithoutDonanteInput>
  }

  export type DonacionUpdateWithWhereUniqueWithoutDonanteInput = {
    where: DonacionWhereUniqueInput
    data: XOR<DonacionUpdateWithoutDonanteInput, DonacionUncheckedUpdateWithoutDonanteInput>
  }

  export type DonacionUpdateManyWithWhereWithoutDonanteInput = {
    where: DonacionScalarWhereInput
    data: XOR<DonacionUpdateManyMutationInput, DonacionUncheckedUpdateManyWithoutDonanteInput>
  }

  export type DonacionScalarWhereInput = {
    AND?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
    OR?: DonacionScalarWhereInput[]
    NOT?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
    id?: IntFilter<"Donacion"> | number
    fecha_donacion?: DateTimeFilter<"Donacion"> | Date | string
    tipo_donacion?: EnumTipoDonacionFilter<"Donacion"> | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFilter<"Donacion"> | $Enums.EstadoDonacion
    DonanteId?: IntFilter<"Donacion"> | number
    campaniaId?: IntNullableFilter<"Donacion"> | number | null
    hospitalId?: IntNullableFilter<"Donacion"> | number | null
  }

  export type HospitalCreateWithoutCampaniasInput = {
    nombre: string
    direccion: string
    numero: number
    telefono: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    donaciones?: DonacionCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutCampaniasInput = {
    id?: number
    nombre: string
    direccion: string
    numero: number
    telefono: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    donaciones?: DonacionUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutCampaniasInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutCampaniasInput, HospitalUncheckedCreateWithoutCampaniasInput>
  }

  export type DonacionCreateWithoutCampaniaInput = {
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    donante: DonanteCreateNestedOneWithoutDonacionesInput
    hospital?: HospitalCreateNestedOneWithoutDonacionesInput
  }

  export type DonacionUncheckedCreateWithoutCampaniaInput = {
    id?: number
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    DonanteId: number
    hospitalId?: number | null
  }

  export type DonacionCreateOrConnectWithoutCampaniaInput = {
    where: DonacionWhereUniqueInput
    create: XOR<DonacionCreateWithoutCampaniaInput, DonacionUncheckedCreateWithoutCampaniaInput>
  }

  export type DonacionCreateManyCampaniaInputEnvelope = {
    data: DonacionCreateManyCampaniaInput | DonacionCreateManyCampaniaInput[]
    skipDuplicates?: boolean
  }

  export type HospitalUpsertWithoutCampaniasInput = {
    update: XOR<HospitalUpdateWithoutCampaniasInput, HospitalUncheckedUpdateWithoutCampaniasInput>
    create: XOR<HospitalCreateWithoutCampaniasInput, HospitalUncheckedCreateWithoutCampaniasInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutCampaniasInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutCampaniasInput, HospitalUncheckedUpdateWithoutCampaniasInput>
  }

  export type HospitalUpdateWithoutCampaniasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    telefono?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donaciones?: DonacionUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutCampaniasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    telefono?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donaciones?: DonacionUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type DonacionUpsertWithWhereUniqueWithoutCampaniaInput = {
    where: DonacionWhereUniqueInput
    update: XOR<DonacionUpdateWithoutCampaniaInput, DonacionUncheckedUpdateWithoutCampaniaInput>
    create: XOR<DonacionCreateWithoutCampaniaInput, DonacionUncheckedCreateWithoutCampaniaInput>
  }

  export type DonacionUpdateWithWhereUniqueWithoutCampaniaInput = {
    where: DonacionWhereUniqueInput
    data: XOR<DonacionUpdateWithoutCampaniaInput, DonacionUncheckedUpdateWithoutCampaniaInput>
  }

  export type DonacionUpdateManyWithWhereWithoutCampaniaInput = {
    where: DonacionScalarWhereInput
    data: XOR<DonacionUpdateManyMutationInput, DonacionUncheckedUpdateManyWithoutCampaniaInput>
  }

  export type CampaniaCreateWithoutHospitalInput = {
    nombre: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    ubicacion: string
    donaciones?: DonacionCreateNestedManyWithoutCampaniaInput
  }

  export type CampaniaUncheckedCreateWithoutHospitalInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    ubicacion: string
    donaciones?: DonacionUncheckedCreateNestedManyWithoutCampaniaInput
  }

  export type CampaniaCreateOrConnectWithoutHospitalInput = {
    where: CampaniaWhereUniqueInput
    create: XOR<CampaniaCreateWithoutHospitalInput, CampaniaUncheckedCreateWithoutHospitalInput>
  }

  export type CampaniaCreateManyHospitalInputEnvelope = {
    data: CampaniaCreateManyHospitalInput | CampaniaCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type DonacionCreateWithoutHospitalInput = {
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    donante: DonanteCreateNestedOneWithoutDonacionesInput
    campania?: CampaniaCreateNestedOneWithoutDonacionesInput
  }

  export type DonacionUncheckedCreateWithoutHospitalInput = {
    id?: number
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    DonanteId: number
    campaniaId?: number | null
  }

  export type DonacionCreateOrConnectWithoutHospitalInput = {
    where: DonacionWhereUniqueInput
    create: XOR<DonacionCreateWithoutHospitalInput, DonacionUncheckedCreateWithoutHospitalInput>
  }

  export type DonacionCreateManyHospitalInputEnvelope = {
    data: DonacionCreateManyHospitalInput | DonacionCreateManyHospitalInput[]
    skipDuplicates?: boolean
  }

  export type CampaniaUpsertWithWhereUniqueWithoutHospitalInput = {
    where: CampaniaWhereUniqueInput
    update: XOR<CampaniaUpdateWithoutHospitalInput, CampaniaUncheckedUpdateWithoutHospitalInput>
    create: XOR<CampaniaCreateWithoutHospitalInput, CampaniaUncheckedCreateWithoutHospitalInput>
  }

  export type CampaniaUpdateWithWhereUniqueWithoutHospitalInput = {
    where: CampaniaWhereUniqueInput
    data: XOR<CampaniaUpdateWithoutHospitalInput, CampaniaUncheckedUpdateWithoutHospitalInput>
  }

  export type CampaniaUpdateManyWithWhereWithoutHospitalInput = {
    where: CampaniaScalarWhereInput
    data: XOR<CampaniaUpdateManyMutationInput, CampaniaUncheckedUpdateManyWithoutHospitalInput>
  }

  export type CampaniaScalarWhereInput = {
    AND?: CampaniaScalarWhereInput | CampaniaScalarWhereInput[]
    OR?: CampaniaScalarWhereInput[]
    NOT?: CampaniaScalarWhereInput | CampaniaScalarWhereInput[]
    id?: IntFilter<"Campania"> | number
    nombre?: StringFilter<"Campania"> | string
    descripcion?: StringNullableFilter<"Campania"> | string | null
    fecha_inicio?: DateTimeFilter<"Campania"> | Date | string
    fecha_fin?: DateTimeNullableFilter<"Campania"> | Date | string | null
    ubicacion?: StringFilter<"Campania"> | string
    hospitalId?: IntFilter<"Campania"> | number
  }

  export type DonacionUpsertWithWhereUniqueWithoutHospitalInput = {
    where: DonacionWhereUniqueInput
    update: XOR<DonacionUpdateWithoutHospitalInput, DonacionUncheckedUpdateWithoutHospitalInput>
    create: XOR<DonacionCreateWithoutHospitalInput, DonacionUncheckedCreateWithoutHospitalInput>
  }

  export type DonacionUpdateWithWhereUniqueWithoutHospitalInput = {
    where: DonacionWhereUniqueInput
    data: XOR<DonacionUpdateWithoutHospitalInput, DonacionUncheckedUpdateWithoutHospitalInput>
  }

  export type DonacionUpdateManyWithWhereWithoutHospitalInput = {
    where: DonacionScalarWhereInput
    data: XOR<DonacionUpdateManyMutationInput, DonacionUncheckedUpdateManyWithoutHospitalInput>
  }

  export type DonanteCreateWithoutDonacionesInput = {
    dni: string
    nombre: string
    apellido: string
    email: string
    password: string
    createdAt?: Date | string
    isActive?: boolean
    grupo_sanguineo: $Enums.GrupoSanguineo
    factor_rh: $Enums.FatorRH
    fecha_nacimiento: Date | string
    sexo: $Enums.Sexo
    fecha_ultima_donacion?: Date | string | null
    estado?: $Enums.EstadoDonante
  }

  export type DonanteUncheckedCreateWithoutDonacionesInput = {
    id?: number
    dni: string
    nombre: string
    apellido: string
    email: string
    password: string
    createdAt?: Date | string
    isActive?: boolean
    grupo_sanguineo: $Enums.GrupoSanguineo
    factor_rh: $Enums.FatorRH
    fecha_nacimiento: Date | string
    sexo: $Enums.Sexo
    fecha_ultima_donacion?: Date | string | null
    estado?: $Enums.EstadoDonante
  }

  export type DonanteCreateOrConnectWithoutDonacionesInput = {
    where: DonanteWhereUniqueInput
    create: XOR<DonanteCreateWithoutDonacionesInput, DonanteUncheckedCreateWithoutDonacionesInput>
  }

  export type CampaniaCreateWithoutDonacionesInput = {
    nombre: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    ubicacion: string
    hospital: HospitalCreateNestedOneWithoutCampaniasInput
  }

  export type CampaniaUncheckedCreateWithoutDonacionesInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    ubicacion: string
    hospitalId: number
  }

  export type CampaniaCreateOrConnectWithoutDonacionesInput = {
    where: CampaniaWhereUniqueInput
    create: XOR<CampaniaCreateWithoutDonacionesInput, CampaniaUncheckedCreateWithoutDonacionesInput>
  }

  export type HospitalCreateWithoutDonacionesInput = {
    nombre: string
    direccion: string
    numero: number
    telefono: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    campanias?: CampaniaCreateNestedManyWithoutHospitalInput
  }

  export type HospitalUncheckedCreateWithoutDonacionesInput = {
    id?: number
    nombre: string
    direccion: string
    numero: number
    telefono: bigint | number
    isActive?: boolean
    createdAt?: Date | string
    campanias?: CampaniaUncheckedCreateNestedManyWithoutHospitalInput
  }

  export type HospitalCreateOrConnectWithoutDonacionesInput = {
    where: HospitalWhereUniqueInput
    create: XOR<HospitalCreateWithoutDonacionesInput, HospitalUncheckedCreateWithoutDonacionesInput>
  }

  export type DonanteUpsertWithoutDonacionesInput = {
    update: XOR<DonanteUpdateWithoutDonacionesInput, DonanteUncheckedUpdateWithoutDonacionesInput>
    create: XOR<DonanteCreateWithoutDonacionesInput, DonanteUncheckedCreateWithoutDonacionesInput>
    where?: DonanteWhereInput
  }

  export type DonanteUpdateToOneWithWhereWithoutDonacionesInput = {
    where?: DonanteWhereInput
    data: XOR<DonanteUpdateWithoutDonacionesInput, DonanteUncheckedUpdateWithoutDonacionesInput>
  }

  export type DonanteUpdateWithoutDonacionesInput = {
    dni?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    grupo_sanguineo?: EnumGrupoSanguineoFieldUpdateOperationsInput | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHFieldUpdateOperationsInput | $Enums.FatorRH
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    fecha_ultima_donacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoDonanteFieldUpdateOperationsInput | $Enums.EstadoDonante
  }

  export type DonanteUncheckedUpdateWithoutDonacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    dni?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    grupo_sanguineo?: EnumGrupoSanguineoFieldUpdateOperationsInput | $Enums.GrupoSanguineo
    factor_rh?: EnumFatorRHFieldUpdateOperationsInput | $Enums.FatorRH
    fecha_nacimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    fecha_ultima_donacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoDonanteFieldUpdateOperationsInput | $Enums.EstadoDonante
  }

  export type CampaniaUpsertWithoutDonacionesInput = {
    update: XOR<CampaniaUpdateWithoutDonacionesInput, CampaniaUncheckedUpdateWithoutDonacionesInput>
    create: XOR<CampaniaCreateWithoutDonacionesInput, CampaniaUncheckedCreateWithoutDonacionesInput>
    where?: CampaniaWhereInput
  }

  export type CampaniaUpdateToOneWithWhereWithoutDonacionesInput = {
    where?: CampaniaWhereInput
    data: XOR<CampaniaUpdateWithoutDonacionesInput, CampaniaUncheckedUpdateWithoutDonacionesInput>
  }

  export type CampaniaUpdateWithoutDonacionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
    hospital?: HospitalUpdateOneRequiredWithoutCampaniasNestedInput
  }

  export type CampaniaUncheckedUpdateWithoutDonacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
    hospitalId?: IntFieldUpdateOperationsInput | number
  }

  export type HospitalUpsertWithoutDonacionesInput = {
    update: XOR<HospitalUpdateWithoutDonacionesInput, HospitalUncheckedUpdateWithoutDonacionesInput>
    create: XOR<HospitalCreateWithoutDonacionesInput, HospitalUncheckedCreateWithoutDonacionesInput>
    where?: HospitalWhereInput
  }

  export type HospitalUpdateToOneWithWhereWithoutDonacionesInput = {
    where?: HospitalWhereInput
    data: XOR<HospitalUpdateWithoutDonacionesInput, HospitalUncheckedUpdateWithoutDonacionesInput>
  }

  export type HospitalUpdateWithoutDonacionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    telefono?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campanias?: CampaniaUpdateManyWithoutHospitalNestedInput
  }

  export type HospitalUncheckedUpdateWithoutDonacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    telefono?: BigIntFieldUpdateOperationsInput | bigint | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campanias?: CampaniaUncheckedUpdateManyWithoutHospitalNestedInput
  }

  export type DonacionCreateManyDonanteInput = {
    id?: number
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    campaniaId?: number | null
    hospitalId?: number | null
  }

  export type DonacionUpdateWithoutDonanteInput = {
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    campania?: CampaniaUpdateOneWithoutDonacionesNestedInput
    hospital?: HospitalUpdateOneWithoutDonacionesNestedInput
  }

  export type DonacionUncheckedUpdateWithoutDonanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    campaniaId?: NullableIntFieldUpdateOperationsInput | number | null
    hospitalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DonacionUncheckedUpdateManyWithoutDonanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    campaniaId?: NullableIntFieldUpdateOperationsInput | number | null
    hospitalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DonacionCreateManyCampaniaInput = {
    id?: number
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    DonanteId: number
    hospitalId?: number | null
  }

  export type DonacionUpdateWithoutCampaniaInput = {
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    donante?: DonanteUpdateOneRequiredWithoutDonacionesNestedInput
    hospital?: HospitalUpdateOneWithoutDonacionesNestedInput
  }

  export type DonacionUncheckedUpdateWithoutCampaniaInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    DonanteId?: IntFieldUpdateOperationsInput | number
    hospitalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DonacionUncheckedUpdateManyWithoutCampaniaInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    DonanteId?: IntFieldUpdateOperationsInput | number
    hospitalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CampaniaCreateManyHospitalInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    fecha_inicio: Date | string
    fecha_fin?: Date | string | null
    ubicacion: string
  }

  export type DonacionCreateManyHospitalInput = {
    id?: number
    fecha_donacion: Date | string
    tipo_donacion: $Enums.TipoDonacion
    estado?: $Enums.EstadoDonacion
    DonanteId: number
    campaniaId?: number | null
  }

  export type CampaniaUpdateWithoutHospitalInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
    donaciones?: DonacionUpdateManyWithoutCampaniaNestedInput
  }

  export type CampaniaUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
    donaciones?: DonacionUncheckedUpdateManyWithoutCampaniaNestedInput
  }

  export type CampaniaUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fecha_fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ubicacion?: StringFieldUpdateOperationsInput | string
  }

  export type DonacionUpdateWithoutHospitalInput = {
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    donante?: DonanteUpdateOneRequiredWithoutDonacionesNestedInput
    campania?: CampaniaUpdateOneWithoutDonacionesNestedInput
  }

  export type DonacionUncheckedUpdateWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    DonanteId?: IntFieldUpdateOperationsInput | number
    campaniaId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DonacionUncheckedUpdateManyWithoutHospitalInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_donacion?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_donacion?: EnumTipoDonacionFieldUpdateOperationsInput | $Enums.TipoDonacion
    estado?: EnumEstadoDonacionFieldUpdateOperationsInput | $Enums.EstadoDonacion
    DonanteId?: IntFieldUpdateOperationsInput | number
    campaniaId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}